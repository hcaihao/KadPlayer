/* soapC.cpp
   Generated by gSOAP 2.8.17r from service.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.17r 2014-05-16 15:46:15 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns1__UserSetting:
		return soap_in_ns1__UserSetting(soap, NULL, NULL, "ns1:UserSetting");
	case SOAP_TYPE_PointerTo_ns1__SetPlayLogResponse:
		return soap_in_PointerTo_ns1__SetPlayLogResponse(soap, NULL, NULL, "ns1:SetPlayLogResponse");
	case SOAP_TYPE_PointerTo_ns1__SetPlayLog:
		return soap_in_PointerTo_ns1__SetPlayLog(soap, NULL, NULL, "ns1:SetPlayLog");
	case SOAP_TYPE_PointerTo_ns1__SetFeedbackResponse:
		return soap_in_PointerTo_ns1__SetFeedbackResponse(soap, NULL, NULL, "ns1:SetFeedbackResponse");
	case SOAP_TYPE_PointerTo_ns1__SetFeedback:
		return soap_in_PointerTo_ns1__SetFeedback(soap, NULL, NULL, "ns1:SetFeedback");
	case SOAP_TYPE_PointerTo_ns1__SetSearchLogResponse:
		return soap_in_PointerTo_ns1__SetSearchLogResponse(soap, NULL, NULL, "ns1:SetSearchLogResponse");
	case SOAP_TYPE_PointerTo_ns1__SetSearchLog:
		return soap_in_PointerTo_ns1__SetSearchLog(soap, NULL, NULL, "ns1:SetSearchLog");
	case SOAP_TYPE_PointerTo_ns1__GetRandomWordResponse:
		return soap_in_PointerTo_ns1__GetRandomWordResponse(soap, NULL, NULL, "ns1:GetRandomWordResponse");
	case SOAP_TYPE_PointerTo_ns1__GetRandomWord:
		return soap_in_PointerTo_ns1__GetRandomWord(soap, NULL, NULL, "ns1:GetRandomWord");
	case SOAP_TYPE_PointerTo_ns1__GetHotEd2ksResponse:
		return soap_in_PointerTo_ns1__GetHotEd2ksResponse(soap, NULL, NULL, "ns1:GetHotEd2ksResponse");
	case SOAP_TYPE_PointerTo_ns1__GetHotEd2ks:
		return soap_in_PointerTo_ns1__GetHotEd2ks(soap, NULL, NULL, "ns1:GetHotEd2ks");
	case SOAP_TYPE_PointerTo_ns1__GetHotWordsResponse:
		return soap_in_PointerTo_ns1__GetHotWordsResponse(soap, NULL, NULL, "ns1:GetHotWordsResponse");
	case SOAP_TYPE_PointerTo_ns1__GetHotWords:
		return soap_in_PointerTo_ns1__GetHotWords(soap, NULL, NULL, "ns1:GetHotWords");
	case SOAP_TYPE_PointerTo_ns1__GetSensitiveWordsResponse:
		return soap_in_PointerTo_ns1__GetSensitiveWordsResponse(soap, NULL, NULL, "ns1:GetSensitiveWordsResponse");
	case SOAP_TYPE_PointerTo_ns1__GetSensitiveWords:
		return soap_in_PointerTo_ns1__GetSensitiveWords(soap, NULL, NULL, "ns1:GetSensitiveWords");
	case SOAP_TYPE_PointerTo_ns1__GetUserSettingResponse:
		return soap_in_PointerTo_ns1__GetUserSettingResponse(soap, NULL, NULL, "ns1:GetUserSettingResponse");
	case SOAP_TYPE_PointerTo_ns1__GetUserSetting:
		return soap_in_PointerTo_ns1__GetUserSetting(soap, NULL, NULL, "ns1:GetUserSetting");
	case SOAP_TYPE_PointerTo_ns1__GetSystemMessageResponse:
		return soap_in_PointerTo_ns1__GetSystemMessageResponse(soap, NULL, NULL, "ns1:GetSystemMessageResponse");
	case SOAP_TYPE_PointerTo_ns1__GetSystemMessage:
		return soap_in_PointerTo_ns1__GetSystemMessage(soap, NULL, NULL, "ns1:GetSystemMessage");
	case SOAP_TYPE_PointerTo_ns1__GetSystemNotifyResponse:
		return soap_in_PointerTo_ns1__GetSystemNotifyResponse(soap, NULL, NULL, "ns1:GetSystemNotifyResponse");
	case SOAP_TYPE_PointerTo_ns1__GetSystemNotify:
		return soap_in_PointerTo_ns1__GetSystemNotify(soap, NULL, NULL, "ns1:GetSystemNotify");
	case SOAP_TYPE_PointerTons1__UserSetting:
		return soap_in_PointerTons1__UserSetting(soap, NULL, NULL, "ns1:UserSetting");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UserSetting"))
		{	*type = SOAP_TYPE_ns1__UserSetting;
			return soap_in_ns1__UserSetting(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:SetPlayLogResponse"))
		{	*type = SOAP_TYPE__ns1__SetPlayLogResponse;
			return soap_in__ns1__SetPlayLogResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetPlayLog"))
		{	*type = SOAP_TYPE__ns1__SetPlayLog;
			return soap_in__ns1__SetPlayLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetFeedbackResponse"))
		{	*type = SOAP_TYPE__ns1__SetFeedbackResponse;
			return soap_in__ns1__SetFeedbackResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetFeedback"))
		{	*type = SOAP_TYPE__ns1__SetFeedback;
			return soap_in__ns1__SetFeedback(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetSearchLogResponse"))
		{	*type = SOAP_TYPE__ns1__SetSearchLogResponse;
			return soap_in__ns1__SetSearchLogResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetSearchLog"))
		{	*type = SOAP_TYPE__ns1__SetSearchLog;
			return soap_in__ns1__SetSearchLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetRandomWordResponse"))
		{	*type = SOAP_TYPE__ns1__GetRandomWordResponse;
			return soap_in__ns1__GetRandomWordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetRandomWord"))
		{	*type = SOAP_TYPE__ns1__GetRandomWord;
			return soap_in__ns1__GetRandomWord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetHotEd2ksResponse"))
		{	*type = SOAP_TYPE__ns1__GetHotEd2ksResponse;
			return soap_in__ns1__GetHotEd2ksResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetHotEd2ks"))
		{	*type = SOAP_TYPE__ns1__GetHotEd2ks;
			return soap_in__ns1__GetHotEd2ks(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetHotWordsResponse"))
		{	*type = SOAP_TYPE__ns1__GetHotWordsResponse;
			return soap_in__ns1__GetHotWordsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetHotWords"))
		{	*type = SOAP_TYPE__ns1__GetHotWords;
			return soap_in__ns1__GetHotWords(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetSensitiveWordsResponse"))
		{	*type = SOAP_TYPE__ns1__GetSensitiveWordsResponse;
			return soap_in__ns1__GetSensitiveWordsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetSensitiveWords"))
		{	*type = SOAP_TYPE__ns1__GetSensitiveWords;
			return soap_in__ns1__GetSensitiveWords(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetUserSettingResponse"))
		{	*type = SOAP_TYPE__ns1__GetUserSettingResponse;
			return soap_in__ns1__GetUserSettingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetUserSetting"))
		{	*type = SOAP_TYPE__ns1__GetUserSetting;
			return soap_in__ns1__GetUserSetting(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetSystemMessageResponse"))
		{	*type = SOAP_TYPE__ns1__GetSystemMessageResponse;
			return soap_in__ns1__GetSystemMessageResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetSystemMessage"))
		{	*type = SOAP_TYPE__ns1__GetSystemMessage;
			return soap_in__ns1__GetSystemMessage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetSystemNotifyResponse"))
		{	*type = SOAP_TYPE__ns1__GetSystemNotifyResponse;
			return soap_in__ns1__GetSystemNotifyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetSystemNotify"))
		{	*type = SOAP_TYPE__ns1__GetSystemNotify;
			return soap_in__ns1__GetSystemNotify(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE__ns1__SetPlayLogResponse:
		return ((_ns1__SetPlayLogResponse *)ptr)->soap_out(soap, "ns1:SetPlayLogResponse", id, NULL);
	case SOAP_TYPE__ns1__SetPlayLog:
		return ((_ns1__SetPlayLog *)ptr)->soap_out(soap, "ns1:SetPlayLog", id, NULL);
	case SOAP_TYPE__ns1__SetFeedbackResponse:
		return ((_ns1__SetFeedbackResponse *)ptr)->soap_out(soap, "ns1:SetFeedbackResponse", id, NULL);
	case SOAP_TYPE__ns1__SetFeedback:
		return ((_ns1__SetFeedback *)ptr)->soap_out(soap, "ns1:SetFeedback", id, NULL);
	case SOAP_TYPE__ns1__SetSearchLogResponse:
		return ((_ns1__SetSearchLogResponse *)ptr)->soap_out(soap, "ns1:SetSearchLogResponse", id, NULL);
	case SOAP_TYPE__ns1__SetSearchLog:
		return ((_ns1__SetSearchLog *)ptr)->soap_out(soap, "ns1:SetSearchLog", id, NULL);
	case SOAP_TYPE__ns1__GetRandomWordResponse:
		return ((_ns1__GetRandomWordResponse *)ptr)->soap_out(soap, "ns1:GetRandomWordResponse", id, NULL);
	case SOAP_TYPE__ns1__GetRandomWord:
		return ((_ns1__GetRandomWord *)ptr)->soap_out(soap, "ns1:GetRandomWord", id, NULL);
	case SOAP_TYPE__ns1__GetHotEd2ksResponse:
		return ((_ns1__GetHotEd2ksResponse *)ptr)->soap_out(soap, "ns1:GetHotEd2ksResponse", id, NULL);
	case SOAP_TYPE__ns1__GetHotEd2ks:
		return ((_ns1__GetHotEd2ks *)ptr)->soap_out(soap, "ns1:GetHotEd2ks", id, NULL);
	case SOAP_TYPE__ns1__GetHotWordsResponse:
		return ((_ns1__GetHotWordsResponse *)ptr)->soap_out(soap, "ns1:GetHotWordsResponse", id, NULL);
	case SOAP_TYPE__ns1__GetHotWords:
		return ((_ns1__GetHotWords *)ptr)->soap_out(soap, "ns1:GetHotWords", id, NULL);
	case SOAP_TYPE__ns1__GetSensitiveWordsResponse:
		return ((_ns1__GetSensitiveWordsResponse *)ptr)->soap_out(soap, "ns1:GetSensitiveWordsResponse", id, NULL);
	case SOAP_TYPE__ns1__GetSensitiveWords:
		return ((_ns1__GetSensitiveWords *)ptr)->soap_out(soap, "ns1:GetSensitiveWords", id, NULL);
	case SOAP_TYPE__ns1__GetUserSettingResponse:
		return ((_ns1__GetUserSettingResponse *)ptr)->soap_out(soap, "ns1:GetUserSettingResponse", id, NULL);
	case SOAP_TYPE__ns1__GetUserSetting:
		return ((_ns1__GetUserSetting *)ptr)->soap_out(soap, "ns1:GetUserSetting", id, NULL);
	case SOAP_TYPE__ns1__GetSystemMessageResponse:
		return ((_ns1__GetSystemMessageResponse *)ptr)->soap_out(soap, "ns1:GetSystemMessageResponse", id, NULL);
	case SOAP_TYPE__ns1__GetSystemMessage:
		return ((_ns1__GetSystemMessage *)ptr)->soap_out(soap, "ns1:GetSystemMessage", id, NULL);
	case SOAP_TYPE__ns1__GetSystemNotifyResponse:
		return ((_ns1__GetSystemNotifyResponse *)ptr)->soap_out(soap, "ns1:GetSystemNotifyResponse", id, NULL);
	case SOAP_TYPE__ns1__GetSystemNotify:
		return ((_ns1__GetSystemNotify *)ptr)->soap_out(soap, "ns1:GetSystemNotify", id, NULL);
	case SOAP_TYPE_ns1__UserSetting:
		return ((ns1__UserSetting *)ptr)->soap_out(soap, tag, id, "ns1:UserSetting");
	case SOAP_TYPE_PointerTo_ns1__SetPlayLogResponse:
		return soap_out_PointerTo_ns1__SetPlayLogResponse(soap, tag, id, (_ns1__SetPlayLogResponse *const*)ptr, "ns1:SetPlayLogResponse");
	case SOAP_TYPE_PointerTo_ns1__SetPlayLog:
		return soap_out_PointerTo_ns1__SetPlayLog(soap, tag, id, (_ns1__SetPlayLog *const*)ptr, "ns1:SetPlayLog");
	case SOAP_TYPE_PointerTo_ns1__SetFeedbackResponse:
		return soap_out_PointerTo_ns1__SetFeedbackResponse(soap, tag, id, (_ns1__SetFeedbackResponse *const*)ptr, "ns1:SetFeedbackResponse");
	case SOAP_TYPE_PointerTo_ns1__SetFeedback:
		return soap_out_PointerTo_ns1__SetFeedback(soap, tag, id, (_ns1__SetFeedback *const*)ptr, "ns1:SetFeedback");
	case SOAP_TYPE_PointerTo_ns1__SetSearchLogResponse:
		return soap_out_PointerTo_ns1__SetSearchLogResponse(soap, tag, id, (_ns1__SetSearchLogResponse *const*)ptr, "ns1:SetSearchLogResponse");
	case SOAP_TYPE_PointerTo_ns1__SetSearchLog:
		return soap_out_PointerTo_ns1__SetSearchLog(soap, tag, id, (_ns1__SetSearchLog *const*)ptr, "ns1:SetSearchLog");
	case SOAP_TYPE_PointerTo_ns1__GetRandomWordResponse:
		return soap_out_PointerTo_ns1__GetRandomWordResponse(soap, tag, id, (_ns1__GetRandomWordResponse *const*)ptr, "ns1:GetRandomWordResponse");
	case SOAP_TYPE_PointerTo_ns1__GetRandomWord:
		return soap_out_PointerTo_ns1__GetRandomWord(soap, tag, id, (_ns1__GetRandomWord *const*)ptr, "ns1:GetRandomWord");
	case SOAP_TYPE_PointerTo_ns1__GetHotEd2ksResponse:
		return soap_out_PointerTo_ns1__GetHotEd2ksResponse(soap, tag, id, (_ns1__GetHotEd2ksResponse *const*)ptr, "ns1:GetHotEd2ksResponse");
	case SOAP_TYPE_PointerTo_ns1__GetHotEd2ks:
		return soap_out_PointerTo_ns1__GetHotEd2ks(soap, tag, id, (_ns1__GetHotEd2ks *const*)ptr, "ns1:GetHotEd2ks");
	case SOAP_TYPE_PointerTo_ns1__GetHotWordsResponse:
		return soap_out_PointerTo_ns1__GetHotWordsResponse(soap, tag, id, (_ns1__GetHotWordsResponse *const*)ptr, "ns1:GetHotWordsResponse");
	case SOAP_TYPE_PointerTo_ns1__GetHotWords:
		return soap_out_PointerTo_ns1__GetHotWords(soap, tag, id, (_ns1__GetHotWords *const*)ptr, "ns1:GetHotWords");
	case SOAP_TYPE_PointerTo_ns1__GetSensitiveWordsResponse:
		return soap_out_PointerTo_ns1__GetSensitiveWordsResponse(soap, tag, id, (_ns1__GetSensitiveWordsResponse *const*)ptr, "ns1:GetSensitiveWordsResponse");
	case SOAP_TYPE_PointerTo_ns1__GetSensitiveWords:
		return soap_out_PointerTo_ns1__GetSensitiveWords(soap, tag, id, (_ns1__GetSensitiveWords *const*)ptr, "ns1:GetSensitiveWords");
	case SOAP_TYPE_PointerTo_ns1__GetUserSettingResponse:
		return soap_out_PointerTo_ns1__GetUserSettingResponse(soap, tag, id, (_ns1__GetUserSettingResponse *const*)ptr, "ns1:GetUserSettingResponse");
	case SOAP_TYPE_PointerTo_ns1__GetUserSetting:
		return soap_out_PointerTo_ns1__GetUserSetting(soap, tag, id, (_ns1__GetUserSetting *const*)ptr, "ns1:GetUserSetting");
	case SOAP_TYPE_PointerTo_ns1__GetSystemMessageResponse:
		return soap_out_PointerTo_ns1__GetSystemMessageResponse(soap, tag, id, (_ns1__GetSystemMessageResponse *const*)ptr, "ns1:GetSystemMessageResponse");
	case SOAP_TYPE_PointerTo_ns1__GetSystemMessage:
		return soap_out_PointerTo_ns1__GetSystemMessage(soap, tag, id, (_ns1__GetSystemMessage *const*)ptr, "ns1:GetSystemMessage");
	case SOAP_TYPE_PointerTo_ns1__GetSystemNotifyResponse:
		return soap_out_PointerTo_ns1__GetSystemNotifyResponse(soap, tag, id, (_ns1__GetSystemNotifyResponse *const*)ptr, "ns1:GetSystemNotifyResponse");
	case SOAP_TYPE_PointerTo_ns1__GetSystemNotify:
		return soap_out_PointerTo_ns1__GetSystemNotify(soap, tag, id, (_ns1__GetSystemNotify *const*)ptr, "ns1:GetSystemNotify");
	case SOAP_TYPE_PointerTons1__UserSetting:
		return soap_out_PointerTons1__UserSetting(soap, tag, id, (ns1__UserSetting *const*)ptr, "ns1:UserSetting");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__ns1__SetPlayLogResponse:
		((_ns1__SetPlayLogResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetPlayLog:
		((_ns1__SetPlayLog *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetFeedbackResponse:
		((_ns1__SetFeedbackResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetFeedback:
		((_ns1__SetFeedback *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetSearchLogResponse:
		((_ns1__SetSearchLogResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetSearchLog:
		((_ns1__SetSearchLog *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetRandomWordResponse:
		((_ns1__GetRandomWordResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetRandomWord:
		((_ns1__GetRandomWord *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetHotEd2ksResponse:
		((_ns1__GetHotEd2ksResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetHotEd2ks:
		((_ns1__GetHotEd2ks *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetHotWordsResponse:
		((_ns1__GetHotWordsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetHotWords:
		((_ns1__GetHotWords *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetSensitiveWordsResponse:
		((_ns1__GetSensitiveWordsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetSensitiveWords:
		((_ns1__GetSensitiveWords *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetUserSettingResponse:
		((_ns1__GetUserSettingResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetUserSetting:
		((_ns1__GetUserSetting *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetSystemMessageResponse:
		((_ns1__GetSystemMessageResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetSystemMessage:
		((_ns1__GetSystemMessage *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetSystemNotifyResponse:
		((_ns1__GetSystemNotifyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetSystemNotify:
		((_ns1__GetSystemNotify *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UserSetting:
		((ns1__UserSetting *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__SetPlayLog_:
		soap_serialize___ns1__SetPlayLog_(soap, (const struct __ns1__SetPlayLog_ *)ptr);
		break;
	case SOAP_TYPE___ns1__SetFeedback_:
		soap_serialize___ns1__SetFeedback_(soap, (const struct __ns1__SetFeedback_ *)ptr);
		break;
	case SOAP_TYPE___ns1__SetSearchLog_:
		soap_serialize___ns1__SetSearchLog_(soap, (const struct __ns1__SetSearchLog_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetRandomWord_:
		soap_serialize___ns1__GetRandomWord_(soap, (const struct __ns1__GetRandomWord_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetHotEd2ks_:
		soap_serialize___ns1__GetHotEd2ks_(soap, (const struct __ns1__GetHotEd2ks_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetHotWords_:
		soap_serialize___ns1__GetHotWords_(soap, (const struct __ns1__GetHotWords_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetSensitiveWords_:
		soap_serialize___ns1__GetSensitiveWords_(soap, (const struct __ns1__GetSensitiveWords_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetUserSetting_:
		soap_serialize___ns1__GetUserSetting_(soap, (const struct __ns1__GetUserSetting_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetSystemMessage_:
		soap_serialize___ns1__GetSystemMessage_(soap, (const struct __ns1__GetSystemMessage_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetSystemNotify_:
		soap_serialize___ns1__GetSystemNotify_(soap, (const struct __ns1__GetSystemNotify_ *)ptr);
		break;
	case SOAP_TYPE___ns1__SetPlayLog:
		soap_serialize___ns1__SetPlayLog(soap, (const struct __ns1__SetPlayLog *)ptr);
		break;
	case SOAP_TYPE___ns1__SetFeedback:
		soap_serialize___ns1__SetFeedback(soap, (const struct __ns1__SetFeedback *)ptr);
		break;
	case SOAP_TYPE___ns1__SetSearchLog:
		soap_serialize___ns1__SetSearchLog(soap, (const struct __ns1__SetSearchLog *)ptr);
		break;
	case SOAP_TYPE___ns1__GetRandomWord:
		soap_serialize___ns1__GetRandomWord(soap, (const struct __ns1__GetRandomWord *)ptr);
		break;
	case SOAP_TYPE___ns1__GetHotEd2ks:
		soap_serialize___ns1__GetHotEd2ks(soap, (const struct __ns1__GetHotEd2ks *)ptr);
		break;
	case SOAP_TYPE___ns1__GetHotWords:
		soap_serialize___ns1__GetHotWords(soap, (const struct __ns1__GetHotWords *)ptr);
		break;
	case SOAP_TYPE___ns1__GetSensitiveWords:
		soap_serialize___ns1__GetSensitiveWords(soap, (const struct __ns1__GetSensitiveWords *)ptr);
		break;
	case SOAP_TYPE___ns1__GetUserSetting:
		soap_serialize___ns1__GetUserSetting(soap, (const struct __ns1__GetUserSetting *)ptr);
		break;
	case SOAP_TYPE___ns1__GetSystemMessage:
		soap_serialize___ns1__GetSystemMessage(soap, (const struct __ns1__GetSystemMessage *)ptr);
		break;
	case SOAP_TYPE___ns1__GetSystemNotify:
		soap_serialize___ns1__GetSystemNotify(soap, (const struct __ns1__GetSystemNotify *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetPlayLogResponse:
		soap_serialize_PointerTo_ns1__SetPlayLogResponse(soap, (_ns1__SetPlayLogResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetPlayLog:
		soap_serialize_PointerTo_ns1__SetPlayLog(soap, (_ns1__SetPlayLog *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetFeedbackResponse:
		soap_serialize_PointerTo_ns1__SetFeedbackResponse(soap, (_ns1__SetFeedbackResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetFeedback:
		soap_serialize_PointerTo_ns1__SetFeedback(soap, (_ns1__SetFeedback *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetSearchLogResponse:
		soap_serialize_PointerTo_ns1__SetSearchLogResponse(soap, (_ns1__SetSearchLogResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetSearchLog:
		soap_serialize_PointerTo_ns1__SetSearchLog(soap, (_ns1__SetSearchLog *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetRandomWordResponse:
		soap_serialize_PointerTo_ns1__GetRandomWordResponse(soap, (_ns1__GetRandomWordResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetRandomWord:
		soap_serialize_PointerTo_ns1__GetRandomWord(soap, (_ns1__GetRandomWord *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetHotEd2ksResponse:
		soap_serialize_PointerTo_ns1__GetHotEd2ksResponse(soap, (_ns1__GetHotEd2ksResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetHotEd2ks:
		soap_serialize_PointerTo_ns1__GetHotEd2ks(soap, (_ns1__GetHotEd2ks *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetHotWordsResponse:
		soap_serialize_PointerTo_ns1__GetHotWordsResponse(soap, (_ns1__GetHotWordsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetHotWords:
		soap_serialize_PointerTo_ns1__GetHotWords(soap, (_ns1__GetHotWords *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetSensitiveWordsResponse:
		soap_serialize_PointerTo_ns1__GetSensitiveWordsResponse(soap, (_ns1__GetSensitiveWordsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetSensitiveWords:
		soap_serialize_PointerTo_ns1__GetSensitiveWords(soap, (_ns1__GetSensitiveWords *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetUserSettingResponse:
		soap_serialize_PointerTo_ns1__GetUserSettingResponse(soap, (_ns1__GetUserSettingResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetUserSetting:
		soap_serialize_PointerTo_ns1__GetUserSetting(soap, (_ns1__GetUserSetting *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetSystemMessageResponse:
		soap_serialize_PointerTo_ns1__GetSystemMessageResponse(soap, (_ns1__GetSystemMessageResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetSystemMessage:
		soap_serialize_PointerTo_ns1__GetSystemMessage(soap, (_ns1__GetSystemMessage *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetSystemNotifyResponse:
		soap_serialize_PointerTo_ns1__GetSystemNotifyResponse(soap, (_ns1__GetSystemNotifyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetSystemNotify:
		soap_serialize_PointerTo_ns1__GetSystemNotify(soap, (_ns1__GetSystemNotify *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UserSetting:
		soap_serialize_PointerTons1__UserSetting(soap, (ns1__UserSetting *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_ns1__UserSetting:
		return (void*)soap_instantiate_ns1__UserSetting(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetSystemNotify:
		return (void*)soap_instantiate__ns1__GetSystemNotify(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetSystemNotifyResponse:
		return (void*)soap_instantiate__ns1__GetSystemNotifyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetSystemMessage:
		return (void*)soap_instantiate__ns1__GetSystemMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetSystemMessageResponse:
		return (void*)soap_instantiate__ns1__GetSystemMessageResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetUserSetting:
		return (void*)soap_instantiate__ns1__GetUserSetting(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetUserSettingResponse:
		return (void*)soap_instantiate__ns1__GetUserSettingResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetSensitiveWords:
		return (void*)soap_instantiate__ns1__GetSensitiveWords(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetSensitiveWordsResponse:
		return (void*)soap_instantiate__ns1__GetSensitiveWordsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetHotWords:
		return (void*)soap_instantiate__ns1__GetHotWords(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetHotWordsResponse:
		return (void*)soap_instantiate__ns1__GetHotWordsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetHotEd2ks:
		return (void*)soap_instantiate__ns1__GetHotEd2ks(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetHotEd2ksResponse:
		return (void*)soap_instantiate__ns1__GetHotEd2ksResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetRandomWord:
		return (void*)soap_instantiate__ns1__GetRandomWord(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetRandomWordResponse:
		return (void*)soap_instantiate__ns1__GetRandomWordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetSearchLog:
		return (void*)soap_instantiate__ns1__SetSearchLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetSearchLogResponse:
		return (void*)soap_instantiate__ns1__SetSearchLogResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetFeedback:
		return (void*)soap_instantiate__ns1__SetFeedback(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetFeedbackResponse:
		return (void*)soap_instantiate__ns1__SetFeedbackResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetPlayLog:
		return (void*)soap_instantiate__ns1__SetPlayLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetPlayLogResponse:
		return (void*)soap_instantiate__ns1__SetPlayLogResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetSystemNotify:
		return (void*)soap_instantiate___ns1__GetSystemNotify(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetSystemMessage:
		return (void*)soap_instantiate___ns1__GetSystemMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetUserSetting:
		return (void*)soap_instantiate___ns1__GetUserSetting(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetSensitiveWords:
		return (void*)soap_instantiate___ns1__GetSensitiveWords(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetHotWords:
		return (void*)soap_instantiate___ns1__GetHotWords(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetHotEd2ks:
		return (void*)soap_instantiate___ns1__GetHotEd2ks(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetRandomWord:
		return (void*)soap_instantiate___ns1__GetRandomWord(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SetSearchLog:
		return (void*)soap_instantiate___ns1__SetSearchLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SetFeedback:
		return (void*)soap_instantiate___ns1__SetFeedback(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SetPlayLog:
		return (void*)soap_instantiate___ns1__SetPlayLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetSystemNotify_:
		return (void*)soap_instantiate___ns1__GetSystemNotify_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetSystemMessage_:
		return (void*)soap_instantiate___ns1__GetSystemMessage_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetUserSetting_:
		return (void*)soap_instantiate___ns1__GetUserSetting_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetSensitiveWords_:
		return (void*)soap_instantiate___ns1__GetSensitiveWords_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetHotWords_:
		return (void*)soap_instantiate___ns1__GetHotWords_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetHotEd2ks_:
		return (void*)soap_instantiate___ns1__GetHotEd2ks_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetRandomWord_:
		return (void*)soap_instantiate___ns1__GetRandomWord_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SetSearchLog_:
		return (void*)soap_instantiate___ns1__SetSearchLog_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SetFeedback_:
		return (void*)soap_instantiate___ns1__SetFeedback_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SetPlayLog_:
		return (void*)soap_instantiate___ns1__SetPlayLog_(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_ns1__UserSetting:
		if (p->size < 0)
			SOAP_DELETE((ns1__UserSetting*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__UserSetting*)p->ptr);
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetSystemNotify:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetSystemNotify*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetSystemNotify*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetSystemNotifyResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetSystemNotifyResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetSystemNotifyResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetSystemMessage:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetSystemMessage*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetSystemMessage*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetSystemMessageResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetSystemMessageResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetSystemMessageResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetUserSetting:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetUserSetting*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetUserSetting*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetUserSettingResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetUserSettingResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetUserSettingResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetSensitiveWords:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetSensitiveWords*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetSensitiveWords*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetSensitiveWordsResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetSensitiveWordsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetSensitiveWordsResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetHotWords:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetHotWords*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetHotWords*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetHotWordsResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetHotWordsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetHotWordsResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetHotEd2ks:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetHotEd2ks*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetHotEd2ks*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetHotEd2ksResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetHotEd2ksResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetHotEd2ksResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetRandomWord:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetRandomWord*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetRandomWord*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetRandomWordResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetRandomWordResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetRandomWordResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__SetSearchLog:
		if (p->size < 0)
			SOAP_DELETE((_ns1__SetSearchLog*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__SetSearchLog*)p->ptr);
		break;
	case SOAP_TYPE__ns1__SetSearchLogResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__SetSearchLogResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__SetSearchLogResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__SetFeedback:
		if (p->size < 0)
			SOAP_DELETE((_ns1__SetFeedback*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__SetFeedback*)p->ptr);
		break;
	case SOAP_TYPE__ns1__SetFeedbackResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__SetFeedbackResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__SetFeedbackResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__SetPlayLog:
		if (p->size < 0)
			SOAP_DELETE((_ns1__SetPlayLog*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__SetPlayLog*)p->ptr);
		break;
	case SOAP_TYPE__ns1__SetPlayLogResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__SetPlayLogResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__SetPlayLogResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetSystemNotify:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetSystemNotify*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetSystemNotify*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetSystemMessage:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetSystemMessage*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetSystemMessage*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetUserSetting:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetUserSetting*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetUserSetting*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetSensitiveWords:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetSensitiveWords*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetSensitiveWords*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetHotWords:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetHotWords*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetHotWords*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetHotEd2ks:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetHotEd2ks*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetHotEd2ks*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetRandomWord:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetRandomWord*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetRandomWord*)p->ptr);
		break;
	case SOAP_TYPE___ns1__SetSearchLog:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__SetSearchLog*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__SetSearchLog*)p->ptr);
		break;
	case SOAP_TYPE___ns1__SetFeedback:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__SetFeedback*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__SetFeedback*)p->ptr);
		break;
	case SOAP_TYPE___ns1__SetPlayLog:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__SetPlayLog*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__SetPlayLog*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetSystemNotify_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetSystemNotify_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetSystemNotify_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetSystemMessage_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetSystemMessage_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetSystemMessage_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetUserSetting_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetUserSetting_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetUserSetting_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetSensitiveWords_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetSensitiveWords_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetSensitiveWords_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetHotWords_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetHotWords_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetHotWords_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetHotEd2ks_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetHotEd2ks_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetHotEd2ks_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetRandomWord_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetRandomWord_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetRandomWord_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__SetSearchLog_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__SetSearchLog_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__SetSearchLog_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__SetFeedback_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__SetFeedback_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__SetFeedback_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__SetPlayLog_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__SetPlayLog_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__SetPlayLog_*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::string, n);
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void _ns1__SetPlayLogResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__SetPlayLogResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns1__SetPlayLogResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetPlayLogResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetPlayLogResponse(struct soap *soap, const char *tag, int id, const _ns1__SetPlayLogResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetPlayLogResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetPlayLogResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetPlayLogResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetPlayLogResponse * SOAP_FMAC4 soap_in__ns1__SetPlayLogResponse(struct soap *soap, const char *tag, _ns1__SetPlayLogResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetPlayLogResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetPlayLogResponse, sizeof(_ns1__SetPlayLogResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SetPlayLogResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SetPlayLogResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetPlayLogResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetPlayLogResponse, 0, sizeof(_ns1__SetPlayLogResponse), 0, soap_copy__ns1__SetPlayLogResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__SetPlayLogResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SetPlayLogResponse);
	if (this->soap_out(soap, tag?tag:"ns1:SetPlayLogResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetPlayLogResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetPlayLogResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetPlayLogResponse * SOAP_FMAC4 soap_get__ns1__SetPlayLogResponse(struct soap *soap, _ns1__SetPlayLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetPlayLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__SetPlayLogResponse * SOAP_FMAC2 soap_instantiate__ns1__SetPlayLogResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetPlayLogResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SetPlayLogResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SetPlayLogResponse);
		if (size)
			*size = sizeof(_ns1__SetPlayLogResponse);
		((_ns1__SetPlayLogResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__SetPlayLogResponse, n);
		if (size)
			*size = n * sizeof(_ns1__SetPlayLogResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__SetPlayLogResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__SetPlayLogResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SetPlayLogResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SetPlayLogResponse %p -> %p\n", q, p));
	*(_ns1__SetPlayLogResponse*)p = *(_ns1__SetPlayLogResponse*)q;
}

void _ns1__SetPlayLog::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SetPlayLog::mac = NULL;
	this->_ns1__SetPlayLog::links = NULL;
	/* transient soap skipped */
}

void _ns1__SetPlayLog::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetPlayLog::mac);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetPlayLog::links);
	/* transient soap skipped */
#endif
}

int _ns1__SetPlayLog::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetPlayLog(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetPlayLog(struct soap *soap, const char *tag, int id, const _ns1__SetPlayLog *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetPlayLog), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:mac", -1, &(a->_ns1__SetPlayLog::mac), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:links", -1, &(a->_ns1__SetPlayLog::links), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetPlayLog::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetPlayLog(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetPlayLog * SOAP_FMAC4 soap_in__ns1__SetPlayLog(struct soap *soap, const char *tag, _ns1__SetPlayLog *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetPlayLog *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetPlayLog, sizeof(_ns1__SetPlayLog), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SetPlayLog)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SetPlayLog *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_mac1 = 1;
	size_t soap_flag_links1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mac1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:mac", &(a->_ns1__SetPlayLog::mac), "xsd:string"))
				{	soap_flag_mac1--;
					continue;
				}
			if (soap_flag_links1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:links", &(a->_ns1__SetPlayLog::links), "xsd:string"))
				{	soap_flag_links1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetPlayLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetPlayLog, 0, sizeof(_ns1__SetPlayLog), 0, soap_copy__ns1__SetPlayLog);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__SetPlayLog::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SetPlayLog);
	if (this->soap_out(soap, tag?tag:"ns1:SetPlayLog", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetPlayLog::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetPlayLog(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetPlayLog * SOAP_FMAC4 soap_get__ns1__SetPlayLog(struct soap *soap, _ns1__SetPlayLog *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetPlayLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__SetPlayLog * SOAP_FMAC2 soap_instantiate__ns1__SetPlayLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetPlayLog(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SetPlayLog, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SetPlayLog);
		if (size)
			*size = sizeof(_ns1__SetPlayLog);
		((_ns1__SetPlayLog*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__SetPlayLog, n);
		if (size)
			*size = n * sizeof(_ns1__SetPlayLog);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__SetPlayLog*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__SetPlayLog*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SetPlayLog(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SetPlayLog %p -> %p\n", q, p));
	*(_ns1__SetPlayLog*)p = *(_ns1__SetPlayLog*)q;
}

void _ns1__SetFeedbackResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__SetFeedbackResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns1__SetFeedbackResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetFeedbackResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetFeedbackResponse(struct soap *soap, const char *tag, int id, const _ns1__SetFeedbackResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetFeedbackResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetFeedbackResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetFeedbackResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetFeedbackResponse * SOAP_FMAC4 soap_in__ns1__SetFeedbackResponse(struct soap *soap, const char *tag, _ns1__SetFeedbackResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetFeedbackResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetFeedbackResponse, sizeof(_ns1__SetFeedbackResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SetFeedbackResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SetFeedbackResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetFeedbackResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetFeedbackResponse, 0, sizeof(_ns1__SetFeedbackResponse), 0, soap_copy__ns1__SetFeedbackResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__SetFeedbackResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SetFeedbackResponse);
	if (this->soap_out(soap, tag?tag:"ns1:SetFeedbackResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetFeedbackResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetFeedbackResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetFeedbackResponse * SOAP_FMAC4 soap_get__ns1__SetFeedbackResponse(struct soap *soap, _ns1__SetFeedbackResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetFeedbackResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__SetFeedbackResponse * SOAP_FMAC2 soap_instantiate__ns1__SetFeedbackResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetFeedbackResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SetFeedbackResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SetFeedbackResponse);
		if (size)
			*size = sizeof(_ns1__SetFeedbackResponse);
		((_ns1__SetFeedbackResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__SetFeedbackResponse, n);
		if (size)
			*size = n * sizeof(_ns1__SetFeedbackResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__SetFeedbackResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__SetFeedbackResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SetFeedbackResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SetFeedbackResponse %p -> %p\n", q, p));
	*(_ns1__SetFeedbackResponse*)p = *(_ns1__SetFeedbackResponse*)q;
}

void _ns1__SetFeedback::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SetFeedback::mac = NULL;
	this->_ns1__SetFeedback::version = NULL;
	soap_default_int(soap, &this->_ns1__SetFeedback::type);
	this->_ns1__SetFeedback::content = NULL;
	/* transient soap skipped */
}

void _ns1__SetFeedback::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetFeedback::mac);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetFeedback::version);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetFeedback::content);
	/* transient soap skipped */
#endif
}

int _ns1__SetFeedback::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetFeedback(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetFeedback(struct soap *soap, const char *tag, int id, const _ns1__SetFeedback *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetFeedback), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:mac", -1, &(a->_ns1__SetFeedback::mac), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:version", -1, &(a->_ns1__SetFeedback::version), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:type", -1, &(a->_ns1__SetFeedback::type), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:content", -1, &(a->_ns1__SetFeedback::content), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetFeedback::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetFeedback(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetFeedback * SOAP_FMAC4 soap_in__ns1__SetFeedback(struct soap *soap, const char *tag, _ns1__SetFeedback *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetFeedback *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetFeedback, sizeof(_ns1__SetFeedback), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SetFeedback)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SetFeedback *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_mac1 = 1;
	size_t soap_flag_version1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_content1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mac1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:mac", &(a->_ns1__SetFeedback::mac), "xsd:string"))
				{	soap_flag_mac1--;
					continue;
				}
			if (soap_flag_version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:version", &(a->_ns1__SetFeedback::version), "xsd:string"))
				{	soap_flag_version1--;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:type", &(a->_ns1__SetFeedback::type), "xsd:int"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_content1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:content", &(a->_ns1__SetFeedback::content), "xsd:string"))
				{	soap_flag_content1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetFeedback *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetFeedback, 0, sizeof(_ns1__SetFeedback), 0, soap_copy__ns1__SetFeedback);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__SetFeedback::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SetFeedback);
	if (this->soap_out(soap, tag?tag:"ns1:SetFeedback", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetFeedback::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetFeedback(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetFeedback * SOAP_FMAC4 soap_get__ns1__SetFeedback(struct soap *soap, _ns1__SetFeedback *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetFeedback(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__SetFeedback * SOAP_FMAC2 soap_instantiate__ns1__SetFeedback(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetFeedback(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SetFeedback, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SetFeedback);
		if (size)
			*size = sizeof(_ns1__SetFeedback);
		((_ns1__SetFeedback*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__SetFeedback, n);
		if (size)
			*size = n * sizeof(_ns1__SetFeedback);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__SetFeedback*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__SetFeedback*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SetFeedback(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SetFeedback %p -> %p\n", q, p));
	*(_ns1__SetFeedback*)p = *(_ns1__SetFeedback*)q;
}

void _ns1__SetSearchLogResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__SetSearchLogResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns1__SetSearchLogResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetSearchLogResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetSearchLogResponse(struct soap *soap, const char *tag, int id, const _ns1__SetSearchLogResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetSearchLogResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetSearchLogResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetSearchLogResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetSearchLogResponse * SOAP_FMAC4 soap_in__ns1__SetSearchLogResponse(struct soap *soap, const char *tag, _ns1__SetSearchLogResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetSearchLogResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetSearchLogResponse, sizeof(_ns1__SetSearchLogResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SetSearchLogResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SetSearchLogResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetSearchLogResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetSearchLogResponse, 0, sizeof(_ns1__SetSearchLogResponse), 0, soap_copy__ns1__SetSearchLogResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__SetSearchLogResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SetSearchLogResponse);
	if (this->soap_out(soap, tag?tag:"ns1:SetSearchLogResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetSearchLogResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetSearchLogResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetSearchLogResponse * SOAP_FMAC4 soap_get__ns1__SetSearchLogResponse(struct soap *soap, _ns1__SetSearchLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetSearchLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__SetSearchLogResponse * SOAP_FMAC2 soap_instantiate__ns1__SetSearchLogResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetSearchLogResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SetSearchLogResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SetSearchLogResponse);
		if (size)
			*size = sizeof(_ns1__SetSearchLogResponse);
		((_ns1__SetSearchLogResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__SetSearchLogResponse, n);
		if (size)
			*size = n * sizeof(_ns1__SetSearchLogResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__SetSearchLogResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__SetSearchLogResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SetSearchLogResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SetSearchLogResponse %p -> %p\n", q, p));
	*(_ns1__SetSearchLogResponse*)p = *(_ns1__SetSearchLogResponse*)q;
}

void _ns1__SetSearchLog::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SetSearchLog::mac = NULL;
	this->_ns1__SetSearchLog::keys = NULL;
	/* transient soap skipped */
}

void _ns1__SetSearchLog::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetSearchLog::mac);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetSearchLog::keys);
	/* transient soap skipped */
#endif
}

int _ns1__SetSearchLog::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetSearchLog(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetSearchLog(struct soap *soap, const char *tag, int id, const _ns1__SetSearchLog *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetSearchLog), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:mac", -1, &(a->_ns1__SetSearchLog::mac), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:keys", -1, &(a->_ns1__SetSearchLog::keys), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetSearchLog::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetSearchLog(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetSearchLog * SOAP_FMAC4 soap_in__ns1__SetSearchLog(struct soap *soap, const char *tag, _ns1__SetSearchLog *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetSearchLog *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetSearchLog, sizeof(_ns1__SetSearchLog), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SetSearchLog)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SetSearchLog *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_mac1 = 1;
	size_t soap_flag_keys1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mac1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:mac", &(a->_ns1__SetSearchLog::mac), "xsd:string"))
				{	soap_flag_mac1--;
					continue;
				}
			if (soap_flag_keys1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:keys", &(a->_ns1__SetSearchLog::keys), "xsd:string"))
				{	soap_flag_keys1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetSearchLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetSearchLog, 0, sizeof(_ns1__SetSearchLog), 0, soap_copy__ns1__SetSearchLog);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__SetSearchLog::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SetSearchLog);
	if (this->soap_out(soap, tag?tag:"ns1:SetSearchLog", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetSearchLog::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetSearchLog(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetSearchLog * SOAP_FMAC4 soap_get__ns1__SetSearchLog(struct soap *soap, _ns1__SetSearchLog *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetSearchLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__SetSearchLog * SOAP_FMAC2 soap_instantiate__ns1__SetSearchLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetSearchLog(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SetSearchLog, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SetSearchLog);
		if (size)
			*size = sizeof(_ns1__SetSearchLog);
		((_ns1__SetSearchLog*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__SetSearchLog, n);
		if (size)
			*size = n * sizeof(_ns1__SetSearchLog);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__SetSearchLog*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__SetSearchLog*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SetSearchLog(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SetSearchLog %p -> %p\n", q, p));
	*(_ns1__SetSearchLog*)p = *(_ns1__SetSearchLog*)q;
}

void _ns1__GetRandomWordResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetRandomWordResponse::GetRandomWordResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetRandomWordResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetRandomWordResponse::GetRandomWordResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetRandomWordResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetRandomWordResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetRandomWordResponse(struct soap *soap, const char *tag, int id, const _ns1__GetRandomWordResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetRandomWordResponse), type))
		return soap->error;
	if (a->GetRandomWordResult)
		soap_element_result(soap, "ns1:GetRandomWordResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetRandomWordResult", -1, &(a->_ns1__GetRandomWordResponse::GetRandomWordResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetRandomWordResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetRandomWordResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetRandomWordResponse * SOAP_FMAC4 soap_in__ns1__GetRandomWordResponse(struct soap *soap, const char *tag, _ns1__GetRandomWordResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetRandomWordResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetRandomWordResponse, sizeof(_ns1__GetRandomWordResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetRandomWordResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetRandomWordResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetRandomWordResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetRandomWordResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:GetRandomWordResult", &(a->_ns1__GetRandomWordResponse::GetRandomWordResult), "xsd:string"))
				{	soap_flag_GetRandomWordResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetRandomWordResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetRandomWordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetRandomWordResponse, 0, sizeof(_ns1__GetRandomWordResponse), 0, soap_copy__ns1__GetRandomWordResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetRandomWordResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetRandomWordResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetRandomWordResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetRandomWordResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetRandomWordResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetRandomWordResponse * SOAP_FMAC4 soap_get__ns1__GetRandomWordResponse(struct soap *soap, _ns1__GetRandomWordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetRandomWordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetRandomWordResponse * SOAP_FMAC2 soap_instantiate__ns1__GetRandomWordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetRandomWordResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetRandomWordResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetRandomWordResponse);
		if (size)
			*size = sizeof(_ns1__GetRandomWordResponse);
		((_ns1__GetRandomWordResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetRandomWordResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetRandomWordResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetRandomWordResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetRandomWordResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetRandomWordResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetRandomWordResponse %p -> %p\n", q, p));
	*(_ns1__GetRandomWordResponse*)p = *(_ns1__GetRandomWordResponse*)q;
}

void _ns1__GetRandomWord::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetRandomWord::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns1__GetRandomWord::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetRandomWord(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetRandomWord(struct soap *soap, const char *tag, int id, const _ns1__GetRandomWord *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetRandomWord), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetRandomWord::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetRandomWord(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetRandomWord * SOAP_FMAC4 soap_in__ns1__GetRandomWord(struct soap *soap, const char *tag, _ns1__GetRandomWord *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetRandomWord *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetRandomWord, sizeof(_ns1__GetRandomWord), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetRandomWord)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetRandomWord *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetRandomWord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetRandomWord, 0, sizeof(_ns1__GetRandomWord), 0, soap_copy__ns1__GetRandomWord);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetRandomWord::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetRandomWord);
	if (this->soap_out(soap, tag?tag:"ns1:GetRandomWord", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetRandomWord::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetRandomWord(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetRandomWord * SOAP_FMAC4 soap_get__ns1__GetRandomWord(struct soap *soap, _ns1__GetRandomWord *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetRandomWord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetRandomWord * SOAP_FMAC2 soap_instantiate__ns1__GetRandomWord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetRandomWord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetRandomWord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetRandomWord);
		if (size)
			*size = sizeof(_ns1__GetRandomWord);
		((_ns1__GetRandomWord*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetRandomWord, n);
		if (size)
			*size = n * sizeof(_ns1__GetRandomWord);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetRandomWord*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetRandomWord*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetRandomWord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetRandomWord %p -> %p\n", q, p));
	*(_ns1__GetRandomWord*)p = *(_ns1__GetRandomWord*)q;
}

void _ns1__GetHotEd2ksResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetHotEd2ksResponse::GetHotEd2ksResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetHotEd2ksResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetHotEd2ksResponse::GetHotEd2ksResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetHotEd2ksResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetHotEd2ksResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetHotEd2ksResponse(struct soap *soap, const char *tag, int id, const _ns1__GetHotEd2ksResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetHotEd2ksResponse), type))
		return soap->error;
	if (a->GetHotEd2ksResult)
		soap_element_result(soap, "ns1:GetHotEd2ksResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetHotEd2ksResult", -1, &(a->_ns1__GetHotEd2ksResponse::GetHotEd2ksResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetHotEd2ksResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetHotEd2ksResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetHotEd2ksResponse * SOAP_FMAC4 soap_in__ns1__GetHotEd2ksResponse(struct soap *soap, const char *tag, _ns1__GetHotEd2ksResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetHotEd2ksResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetHotEd2ksResponse, sizeof(_ns1__GetHotEd2ksResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetHotEd2ksResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetHotEd2ksResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetHotEd2ksResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetHotEd2ksResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:GetHotEd2ksResult", &(a->_ns1__GetHotEd2ksResponse::GetHotEd2ksResult), "xsd:string"))
				{	soap_flag_GetHotEd2ksResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetHotEd2ksResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetHotEd2ksResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetHotEd2ksResponse, 0, sizeof(_ns1__GetHotEd2ksResponse), 0, soap_copy__ns1__GetHotEd2ksResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetHotEd2ksResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetHotEd2ksResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetHotEd2ksResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetHotEd2ksResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetHotEd2ksResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetHotEd2ksResponse * SOAP_FMAC4 soap_get__ns1__GetHotEd2ksResponse(struct soap *soap, _ns1__GetHotEd2ksResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetHotEd2ksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetHotEd2ksResponse * SOAP_FMAC2 soap_instantiate__ns1__GetHotEd2ksResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetHotEd2ksResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetHotEd2ksResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetHotEd2ksResponse);
		if (size)
			*size = sizeof(_ns1__GetHotEd2ksResponse);
		((_ns1__GetHotEd2ksResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetHotEd2ksResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetHotEd2ksResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetHotEd2ksResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetHotEd2ksResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetHotEd2ksResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetHotEd2ksResponse %p -> %p\n", q, p));
	*(_ns1__GetHotEd2ksResponse*)p = *(_ns1__GetHotEd2ksResponse*)q;
}

void _ns1__GetHotEd2ks::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetHotEd2ks::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns1__GetHotEd2ks::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetHotEd2ks(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetHotEd2ks(struct soap *soap, const char *tag, int id, const _ns1__GetHotEd2ks *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetHotEd2ks), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetHotEd2ks::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetHotEd2ks(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetHotEd2ks * SOAP_FMAC4 soap_in__ns1__GetHotEd2ks(struct soap *soap, const char *tag, _ns1__GetHotEd2ks *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetHotEd2ks *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetHotEd2ks, sizeof(_ns1__GetHotEd2ks), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetHotEd2ks)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetHotEd2ks *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetHotEd2ks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetHotEd2ks, 0, sizeof(_ns1__GetHotEd2ks), 0, soap_copy__ns1__GetHotEd2ks);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetHotEd2ks::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetHotEd2ks);
	if (this->soap_out(soap, tag?tag:"ns1:GetHotEd2ks", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetHotEd2ks::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetHotEd2ks(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetHotEd2ks * SOAP_FMAC4 soap_get__ns1__GetHotEd2ks(struct soap *soap, _ns1__GetHotEd2ks *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetHotEd2ks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetHotEd2ks * SOAP_FMAC2 soap_instantiate__ns1__GetHotEd2ks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetHotEd2ks(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetHotEd2ks, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetHotEd2ks);
		if (size)
			*size = sizeof(_ns1__GetHotEd2ks);
		((_ns1__GetHotEd2ks*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetHotEd2ks, n);
		if (size)
			*size = n * sizeof(_ns1__GetHotEd2ks);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetHotEd2ks*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetHotEd2ks*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetHotEd2ks(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetHotEd2ks %p -> %p\n", q, p));
	*(_ns1__GetHotEd2ks*)p = *(_ns1__GetHotEd2ks*)q;
}

void _ns1__GetHotWordsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetHotWordsResponse::GetHotWordsResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetHotWordsResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetHotWordsResponse::GetHotWordsResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetHotWordsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetHotWordsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetHotWordsResponse(struct soap *soap, const char *tag, int id, const _ns1__GetHotWordsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetHotWordsResponse), type))
		return soap->error;
	if (a->GetHotWordsResult)
		soap_element_result(soap, "ns1:GetHotWordsResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetHotWordsResult", -1, &(a->_ns1__GetHotWordsResponse::GetHotWordsResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetHotWordsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetHotWordsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetHotWordsResponse * SOAP_FMAC4 soap_in__ns1__GetHotWordsResponse(struct soap *soap, const char *tag, _ns1__GetHotWordsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetHotWordsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetHotWordsResponse, sizeof(_ns1__GetHotWordsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetHotWordsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetHotWordsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetHotWordsResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetHotWordsResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:GetHotWordsResult", &(a->_ns1__GetHotWordsResponse::GetHotWordsResult), "xsd:string"))
				{	soap_flag_GetHotWordsResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetHotWordsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetHotWordsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetHotWordsResponse, 0, sizeof(_ns1__GetHotWordsResponse), 0, soap_copy__ns1__GetHotWordsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetHotWordsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetHotWordsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetHotWordsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetHotWordsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetHotWordsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetHotWordsResponse * SOAP_FMAC4 soap_get__ns1__GetHotWordsResponse(struct soap *soap, _ns1__GetHotWordsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetHotWordsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetHotWordsResponse * SOAP_FMAC2 soap_instantiate__ns1__GetHotWordsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetHotWordsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetHotWordsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetHotWordsResponse);
		if (size)
			*size = sizeof(_ns1__GetHotWordsResponse);
		((_ns1__GetHotWordsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetHotWordsResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetHotWordsResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetHotWordsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetHotWordsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetHotWordsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetHotWordsResponse %p -> %p\n", q, p));
	*(_ns1__GetHotWordsResponse*)p = *(_ns1__GetHotWordsResponse*)q;
}

void _ns1__GetHotWords::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetHotWords::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns1__GetHotWords::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetHotWords(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetHotWords(struct soap *soap, const char *tag, int id, const _ns1__GetHotWords *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetHotWords), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetHotWords::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetHotWords(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetHotWords * SOAP_FMAC4 soap_in__ns1__GetHotWords(struct soap *soap, const char *tag, _ns1__GetHotWords *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetHotWords *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetHotWords, sizeof(_ns1__GetHotWords), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetHotWords)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetHotWords *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetHotWords *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetHotWords, 0, sizeof(_ns1__GetHotWords), 0, soap_copy__ns1__GetHotWords);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetHotWords::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetHotWords);
	if (this->soap_out(soap, tag?tag:"ns1:GetHotWords", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetHotWords::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetHotWords(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetHotWords * SOAP_FMAC4 soap_get__ns1__GetHotWords(struct soap *soap, _ns1__GetHotWords *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetHotWords(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetHotWords * SOAP_FMAC2 soap_instantiate__ns1__GetHotWords(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetHotWords(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetHotWords, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetHotWords);
		if (size)
			*size = sizeof(_ns1__GetHotWords);
		((_ns1__GetHotWords*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetHotWords, n);
		if (size)
			*size = n * sizeof(_ns1__GetHotWords);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetHotWords*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetHotWords*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetHotWords(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetHotWords %p -> %p\n", q, p));
	*(_ns1__GetHotWords*)p = *(_ns1__GetHotWords*)q;
}

void _ns1__GetSensitiveWordsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetSensitiveWordsResponse::GetSensitiveWordsResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetSensitiveWordsResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetSensitiveWordsResponse::GetSensitiveWordsResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetSensitiveWordsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetSensitiveWordsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetSensitiveWordsResponse(struct soap *soap, const char *tag, int id, const _ns1__GetSensitiveWordsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetSensitiveWordsResponse), type))
		return soap->error;
	if (a->GetSensitiveWordsResult)
		soap_element_result(soap, "ns1:GetSensitiveWordsResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetSensitiveWordsResult", -1, &(a->_ns1__GetSensitiveWordsResponse::GetSensitiveWordsResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetSensitiveWordsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetSensitiveWordsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetSensitiveWordsResponse * SOAP_FMAC4 soap_in__ns1__GetSensitiveWordsResponse(struct soap *soap, const char *tag, _ns1__GetSensitiveWordsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetSensitiveWordsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetSensitiveWordsResponse, sizeof(_ns1__GetSensitiveWordsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetSensitiveWordsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetSensitiveWordsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetSensitiveWordsResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetSensitiveWordsResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:GetSensitiveWordsResult", &(a->_ns1__GetSensitiveWordsResponse::GetSensitiveWordsResult), "xsd:string"))
				{	soap_flag_GetSensitiveWordsResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetSensitiveWordsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetSensitiveWordsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetSensitiveWordsResponse, 0, sizeof(_ns1__GetSensitiveWordsResponse), 0, soap_copy__ns1__GetSensitiveWordsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetSensitiveWordsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetSensitiveWordsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetSensitiveWordsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetSensitiveWordsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetSensitiveWordsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetSensitiveWordsResponse * SOAP_FMAC4 soap_get__ns1__GetSensitiveWordsResponse(struct soap *soap, _ns1__GetSensitiveWordsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetSensitiveWordsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetSensitiveWordsResponse * SOAP_FMAC2 soap_instantiate__ns1__GetSensitiveWordsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetSensitiveWordsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetSensitiveWordsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetSensitiveWordsResponse);
		if (size)
			*size = sizeof(_ns1__GetSensitiveWordsResponse);
		((_ns1__GetSensitiveWordsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetSensitiveWordsResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetSensitiveWordsResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetSensitiveWordsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetSensitiveWordsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetSensitiveWordsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetSensitiveWordsResponse %p -> %p\n", q, p));
	*(_ns1__GetSensitiveWordsResponse*)p = *(_ns1__GetSensitiveWordsResponse*)q;
}

void _ns1__GetSensitiveWords::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetSensitiveWords::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns1__GetSensitiveWords::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetSensitiveWords(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetSensitiveWords(struct soap *soap, const char *tag, int id, const _ns1__GetSensitiveWords *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetSensitiveWords), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetSensitiveWords::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetSensitiveWords(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetSensitiveWords * SOAP_FMAC4 soap_in__ns1__GetSensitiveWords(struct soap *soap, const char *tag, _ns1__GetSensitiveWords *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetSensitiveWords *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetSensitiveWords, sizeof(_ns1__GetSensitiveWords), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetSensitiveWords)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetSensitiveWords *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetSensitiveWords *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetSensitiveWords, 0, sizeof(_ns1__GetSensitiveWords), 0, soap_copy__ns1__GetSensitiveWords);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetSensitiveWords::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetSensitiveWords);
	if (this->soap_out(soap, tag?tag:"ns1:GetSensitiveWords", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetSensitiveWords::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetSensitiveWords(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetSensitiveWords * SOAP_FMAC4 soap_get__ns1__GetSensitiveWords(struct soap *soap, _ns1__GetSensitiveWords *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetSensitiveWords(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetSensitiveWords * SOAP_FMAC2 soap_instantiate__ns1__GetSensitiveWords(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetSensitiveWords(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetSensitiveWords, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetSensitiveWords);
		if (size)
			*size = sizeof(_ns1__GetSensitiveWords);
		((_ns1__GetSensitiveWords*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetSensitiveWords, n);
		if (size)
			*size = n * sizeof(_ns1__GetSensitiveWords);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetSensitiveWords*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetSensitiveWords*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetSensitiveWords(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetSensitiveWords %p -> %p\n", q, p));
	*(_ns1__GetSensitiveWords*)p = *(_ns1__GetSensitiveWords*)q;
}

void _ns1__GetUserSettingResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetUserSettingResponse::GetUserSettingResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetUserSettingResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__UserSetting(soap, &this->_ns1__GetUserSettingResponse::GetUserSettingResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetUserSettingResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetUserSettingResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetUserSettingResponse(struct soap *soap, const char *tag, int id, const _ns1__GetUserSettingResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetUserSettingResponse), type))
		return soap->error;
	if (a->GetUserSettingResult)
		soap_element_result(soap, "ns1:GetUserSettingResult");
	if (soap_out_PointerTons1__UserSetting(soap, "ns1:GetUserSettingResult", -1, &(a->_ns1__GetUserSettingResponse::GetUserSettingResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetUserSettingResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetUserSettingResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetUserSettingResponse * SOAP_FMAC4 soap_in__ns1__GetUserSettingResponse(struct soap *soap, const char *tag, _ns1__GetUserSettingResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetUserSettingResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetUserSettingResponse, sizeof(_ns1__GetUserSettingResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetUserSettingResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetUserSettingResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetUserSettingResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetUserSettingResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UserSetting(soap, "ns1:GetUserSettingResult", &(a->_ns1__GetUserSettingResponse::GetUserSettingResult), "ns1:UserSetting"))
				{	soap_flag_GetUserSettingResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetUserSettingResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetUserSettingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetUserSettingResponse, 0, sizeof(_ns1__GetUserSettingResponse), 0, soap_copy__ns1__GetUserSettingResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetUserSettingResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetUserSettingResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetUserSettingResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetUserSettingResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetUserSettingResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetUserSettingResponse * SOAP_FMAC4 soap_get__ns1__GetUserSettingResponse(struct soap *soap, _ns1__GetUserSettingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetUserSettingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetUserSettingResponse * SOAP_FMAC2 soap_instantiate__ns1__GetUserSettingResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetUserSettingResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetUserSettingResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetUserSettingResponse);
		if (size)
			*size = sizeof(_ns1__GetUserSettingResponse);
		((_ns1__GetUserSettingResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetUserSettingResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetUserSettingResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetUserSettingResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetUserSettingResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetUserSettingResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetUserSettingResponse %p -> %p\n", q, p));
	*(_ns1__GetUserSettingResponse*)p = *(_ns1__GetUserSettingResponse*)q;
}

void _ns1__GetUserSetting::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetUserSetting::mac = NULL;
	/* transient soap skipped */
}

void _ns1__GetUserSetting::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetUserSetting::mac);
	/* transient soap skipped */
#endif
}

int _ns1__GetUserSetting::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetUserSetting(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetUserSetting(struct soap *soap, const char *tag, int id, const _ns1__GetUserSetting *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetUserSetting), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:mac", -1, &(a->_ns1__GetUserSetting::mac), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetUserSetting::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetUserSetting(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetUserSetting * SOAP_FMAC4 soap_in__ns1__GetUserSetting(struct soap *soap, const char *tag, _ns1__GetUserSetting *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetUserSetting *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetUserSetting, sizeof(_ns1__GetUserSetting), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetUserSetting)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetUserSetting *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_mac1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mac1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:mac", &(a->_ns1__GetUserSetting::mac), "xsd:string"))
				{	soap_flag_mac1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetUserSetting *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetUserSetting, 0, sizeof(_ns1__GetUserSetting), 0, soap_copy__ns1__GetUserSetting);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetUserSetting::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetUserSetting);
	if (this->soap_out(soap, tag?tag:"ns1:GetUserSetting", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetUserSetting::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetUserSetting(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetUserSetting * SOAP_FMAC4 soap_get__ns1__GetUserSetting(struct soap *soap, _ns1__GetUserSetting *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetUserSetting(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetUserSetting * SOAP_FMAC2 soap_instantiate__ns1__GetUserSetting(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetUserSetting(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetUserSetting, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetUserSetting);
		if (size)
			*size = sizeof(_ns1__GetUserSetting);
		((_ns1__GetUserSetting*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetUserSetting, n);
		if (size)
			*size = n * sizeof(_ns1__GetUserSetting);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetUserSetting*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetUserSetting*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetUserSetting(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetUserSetting %p -> %p\n", q, p));
	*(_ns1__GetUserSetting*)p = *(_ns1__GetUserSetting*)q;
}

void _ns1__GetSystemMessageResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetSystemMessageResponse::GetSystemMessageResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetSystemMessageResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetSystemMessageResponse::GetSystemMessageResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetSystemMessageResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetSystemMessageResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetSystemMessageResponse(struct soap *soap, const char *tag, int id, const _ns1__GetSystemMessageResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetSystemMessageResponse), type))
		return soap->error;
	if (a->GetSystemMessageResult)
		soap_element_result(soap, "ns1:GetSystemMessageResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetSystemMessageResult", -1, &(a->_ns1__GetSystemMessageResponse::GetSystemMessageResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetSystemMessageResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetSystemMessageResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetSystemMessageResponse * SOAP_FMAC4 soap_in__ns1__GetSystemMessageResponse(struct soap *soap, const char *tag, _ns1__GetSystemMessageResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetSystemMessageResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetSystemMessageResponse, sizeof(_ns1__GetSystemMessageResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetSystemMessageResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetSystemMessageResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetSystemMessageResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetSystemMessageResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:GetSystemMessageResult", &(a->_ns1__GetSystemMessageResponse::GetSystemMessageResult), "xsd:string"))
				{	soap_flag_GetSystemMessageResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetSystemMessageResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetSystemMessageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetSystemMessageResponse, 0, sizeof(_ns1__GetSystemMessageResponse), 0, soap_copy__ns1__GetSystemMessageResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetSystemMessageResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetSystemMessageResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetSystemMessageResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetSystemMessageResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetSystemMessageResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetSystemMessageResponse * SOAP_FMAC4 soap_get__ns1__GetSystemMessageResponse(struct soap *soap, _ns1__GetSystemMessageResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetSystemMessageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetSystemMessageResponse * SOAP_FMAC2 soap_instantiate__ns1__GetSystemMessageResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetSystemMessageResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetSystemMessageResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetSystemMessageResponse);
		if (size)
			*size = sizeof(_ns1__GetSystemMessageResponse);
		((_ns1__GetSystemMessageResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetSystemMessageResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetSystemMessageResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetSystemMessageResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetSystemMessageResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetSystemMessageResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetSystemMessageResponse %p -> %p\n", q, p));
	*(_ns1__GetSystemMessageResponse*)p = *(_ns1__GetSystemMessageResponse*)q;
}

void _ns1__GetSystemMessage::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetSystemMessage::mac = NULL;
	this->_ns1__GetSystemMessage::version = NULL;
	this->_ns1__GetSystemMessage::extension = NULL;
	/* transient soap skipped */
}

void _ns1__GetSystemMessage::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetSystemMessage::mac);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetSystemMessage::version);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetSystemMessage::extension);
	/* transient soap skipped */
#endif
}

int _ns1__GetSystemMessage::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetSystemMessage(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetSystemMessage(struct soap *soap, const char *tag, int id, const _ns1__GetSystemMessage *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetSystemMessage), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:mac", -1, &(a->_ns1__GetSystemMessage::mac), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:version", -1, &(a->_ns1__GetSystemMessage::version), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:extension", -1, &(a->_ns1__GetSystemMessage::extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetSystemMessage::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetSystemMessage(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetSystemMessage * SOAP_FMAC4 soap_in__ns1__GetSystemMessage(struct soap *soap, const char *tag, _ns1__GetSystemMessage *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetSystemMessage *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetSystemMessage, sizeof(_ns1__GetSystemMessage), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetSystemMessage)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetSystemMessage *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_mac1 = 1;
	size_t soap_flag_version1 = 1;
	size_t soap_flag_extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mac1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:mac", &(a->_ns1__GetSystemMessage::mac), "xsd:string"))
				{	soap_flag_mac1--;
					continue;
				}
			if (soap_flag_version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:version", &(a->_ns1__GetSystemMessage::version), "xsd:string"))
				{	soap_flag_version1--;
					continue;
				}
			if (soap_flag_extension1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:extension", &(a->_ns1__GetSystemMessage::extension), "xsd:string"))
				{	soap_flag_extension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetSystemMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetSystemMessage, 0, sizeof(_ns1__GetSystemMessage), 0, soap_copy__ns1__GetSystemMessage);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetSystemMessage::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetSystemMessage);
	if (this->soap_out(soap, tag?tag:"ns1:GetSystemMessage", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetSystemMessage::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetSystemMessage(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetSystemMessage * SOAP_FMAC4 soap_get__ns1__GetSystemMessage(struct soap *soap, _ns1__GetSystemMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetSystemMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetSystemMessage * SOAP_FMAC2 soap_instantiate__ns1__GetSystemMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetSystemMessage(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetSystemMessage, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetSystemMessage);
		if (size)
			*size = sizeof(_ns1__GetSystemMessage);
		((_ns1__GetSystemMessage*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetSystemMessage, n);
		if (size)
			*size = n * sizeof(_ns1__GetSystemMessage);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetSystemMessage*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetSystemMessage*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetSystemMessage(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetSystemMessage %p -> %p\n", q, p));
	*(_ns1__GetSystemMessage*)p = *(_ns1__GetSystemMessage*)q;
}

void _ns1__GetSystemNotifyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetSystemNotifyResponse::GetSystemNotifyResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetSystemNotifyResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetSystemNotifyResponse::GetSystemNotifyResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetSystemNotifyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetSystemNotifyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetSystemNotifyResponse(struct soap *soap, const char *tag, int id, const _ns1__GetSystemNotifyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetSystemNotifyResponse), type))
		return soap->error;
	if (a->GetSystemNotifyResult)
		soap_element_result(soap, "ns1:GetSystemNotifyResult");
	if (soap_out_PointerTostd__string(soap, "ns1:GetSystemNotifyResult", -1, &(a->_ns1__GetSystemNotifyResponse::GetSystemNotifyResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetSystemNotifyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetSystemNotifyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetSystemNotifyResponse * SOAP_FMAC4 soap_in__ns1__GetSystemNotifyResponse(struct soap *soap, const char *tag, _ns1__GetSystemNotifyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetSystemNotifyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetSystemNotifyResponse, sizeof(_ns1__GetSystemNotifyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetSystemNotifyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetSystemNotifyResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetSystemNotifyResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetSystemNotifyResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:GetSystemNotifyResult", &(a->_ns1__GetSystemNotifyResponse::GetSystemNotifyResult), "xsd:string"))
				{	soap_flag_GetSystemNotifyResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetSystemNotifyResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetSystemNotifyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetSystemNotifyResponse, 0, sizeof(_ns1__GetSystemNotifyResponse), 0, soap_copy__ns1__GetSystemNotifyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetSystemNotifyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetSystemNotifyResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetSystemNotifyResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetSystemNotifyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetSystemNotifyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetSystemNotifyResponse * SOAP_FMAC4 soap_get__ns1__GetSystemNotifyResponse(struct soap *soap, _ns1__GetSystemNotifyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetSystemNotifyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetSystemNotifyResponse * SOAP_FMAC2 soap_instantiate__ns1__GetSystemNotifyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetSystemNotifyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetSystemNotifyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetSystemNotifyResponse);
		if (size)
			*size = sizeof(_ns1__GetSystemNotifyResponse);
		((_ns1__GetSystemNotifyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetSystemNotifyResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetSystemNotifyResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetSystemNotifyResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetSystemNotifyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetSystemNotifyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetSystemNotifyResponse %p -> %p\n", q, p));
	*(_ns1__GetSystemNotifyResponse*)p = *(_ns1__GetSystemNotifyResponse*)q;
}

void _ns1__GetSystemNotify::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetSystemNotify::mac = NULL;
	this->_ns1__GetSystemNotify::version = NULL;
	/* transient soap skipped */
}

void _ns1__GetSystemNotify::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetSystemNotify::mac);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetSystemNotify::version);
	/* transient soap skipped */
#endif
}

int _ns1__GetSystemNotify::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetSystemNotify(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetSystemNotify(struct soap *soap, const char *tag, int id, const _ns1__GetSystemNotify *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetSystemNotify), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:mac", -1, &(a->_ns1__GetSystemNotify::mac), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:version", -1, &(a->_ns1__GetSystemNotify::version), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetSystemNotify::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetSystemNotify(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetSystemNotify * SOAP_FMAC4 soap_in__ns1__GetSystemNotify(struct soap *soap, const char *tag, _ns1__GetSystemNotify *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetSystemNotify *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetSystemNotify, sizeof(_ns1__GetSystemNotify), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetSystemNotify)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetSystemNotify *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_mac1 = 1;
	size_t soap_flag_version1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mac1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:mac", &(a->_ns1__GetSystemNotify::mac), "xsd:string"))
				{	soap_flag_mac1--;
					continue;
				}
			if (soap_flag_version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:version", &(a->_ns1__GetSystemNotify::version), "xsd:string"))
				{	soap_flag_version1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetSystemNotify *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetSystemNotify, 0, sizeof(_ns1__GetSystemNotify), 0, soap_copy__ns1__GetSystemNotify);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetSystemNotify::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetSystemNotify);
	if (this->soap_out(soap, tag?tag:"ns1:GetSystemNotify", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetSystemNotify::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetSystemNotify(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetSystemNotify * SOAP_FMAC4 soap_get__ns1__GetSystemNotify(struct soap *soap, _ns1__GetSystemNotify *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetSystemNotify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetSystemNotify * SOAP_FMAC2 soap_instantiate__ns1__GetSystemNotify(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetSystemNotify(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetSystemNotify, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetSystemNotify);
		if (size)
			*size = sizeof(_ns1__GetSystemNotify);
		((_ns1__GetSystemNotify*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetSystemNotify, n);
		if (size)
			*size = n * sizeof(_ns1__GetSystemNotify);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetSystemNotify*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetSystemNotify*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetSystemNotify(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetSystemNotify %p -> %p\n", q, p));
	*(_ns1__GetSystemNotify*)p = *(_ns1__GetSystemNotify*)q;
}

void ns1__UserSetting::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__UserSetting::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int ns1__UserSetting::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UserSetting(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UserSetting(struct soap *soap, const char *tag, int id, const ns1__UserSetting *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UserSetting), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__UserSetting::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UserSetting(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UserSetting * SOAP_FMAC4 soap_in_ns1__UserSetting(struct soap *soap, const char *tag, ns1__UserSetting *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UserSetting *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UserSetting, sizeof(ns1__UserSetting), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__UserSetting)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__UserSetting *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__UserSetting *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UserSetting, 0, sizeof(ns1__UserSetting), 0, soap_copy_ns1__UserSetting);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__UserSetting::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__UserSetting);
	if (this->soap_out(soap, tag?tag:"ns1:UserSetting", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__UserSetting::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UserSetting(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UserSetting * SOAP_FMAC4 soap_get_ns1__UserSetting(struct soap *soap, ns1__UserSetting *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UserSetting(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__UserSetting * SOAP_FMAC2 soap_instantiate_ns1__UserSetting(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UserSetting(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UserSetting, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__UserSetting);
		if (size)
			*size = sizeof(ns1__UserSetting);
		((ns1__UserSetting*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__UserSetting, n);
		if (size)
			*size = n * sizeof(ns1__UserSetting);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__UserSetting*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__UserSetting*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UserSetting(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__UserSetting %p -> %p\n", q, p));
	*(ns1__UserSetting*)p = *(ns1__UserSetting*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SetPlayLog_(struct soap *soap, struct __ns1__SetPlayLog_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetPlayLog = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SetPlayLog_(struct soap *soap, const struct __ns1__SetPlayLog_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__SetPlayLog(soap, &a->ns1__SetPlayLog);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SetPlayLog_(struct soap *soap, const char *tag, int id, const struct __ns1__SetPlayLog_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__SetPlayLog(soap, "ns1:SetPlayLog", -1, &a->ns1__SetPlayLog, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetPlayLog_ * SOAP_FMAC4 soap_in___ns1__SetPlayLog_(struct soap *soap, const char *tag, struct __ns1__SetPlayLog_ *a, const char *type)
{
	size_t soap_flag_ns1__SetPlayLog = 1;
	short soap_flag;
	a = (struct __ns1__SetPlayLog_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SetPlayLog_, sizeof(struct __ns1__SetPlayLog_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SetPlayLog_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetPlayLog && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SetPlayLog(soap, "ns1:SetPlayLog", &a->ns1__SetPlayLog, ""))
				{	soap_flag_ns1__SetPlayLog--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SetPlayLog_(struct soap *soap, const struct __ns1__SetPlayLog_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__SetPlayLog_(soap, tag?tag:"-ns1:SetPlayLog", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetPlayLog_ * SOAP_FMAC4 soap_get___ns1__SetPlayLog_(struct soap *soap, struct __ns1__SetPlayLog_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SetPlayLog_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__SetPlayLog_ * SOAP_FMAC2 soap_instantiate___ns1__SetPlayLog_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SetPlayLog_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__SetPlayLog_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__SetPlayLog_);
		if (size)
			*size = sizeof(struct __ns1__SetPlayLog_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__SetPlayLog_, n);
		if (size)
			*size = n * sizeof(struct __ns1__SetPlayLog_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__SetPlayLog_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__SetPlayLog_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__SetPlayLog_ %p -> %p\n", q, p));
	*(struct __ns1__SetPlayLog_*)p = *(struct __ns1__SetPlayLog_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SetFeedback_(struct soap *soap, struct __ns1__SetFeedback_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetFeedback = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SetFeedback_(struct soap *soap, const struct __ns1__SetFeedback_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__SetFeedback(soap, &a->ns1__SetFeedback);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SetFeedback_(struct soap *soap, const char *tag, int id, const struct __ns1__SetFeedback_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__SetFeedback(soap, "ns1:SetFeedback", -1, &a->ns1__SetFeedback, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetFeedback_ * SOAP_FMAC4 soap_in___ns1__SetFeedback_(struct soap *soap, const char *tag, struct __ns1__SetFeedback_ *a, const char *type)
{
	size_t soap_flag_ns1__SetFeedback = 1;
	short soap_flag;
	a = (struct __ns1__SetFeedback_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SetFeedback_, sizeof(struct __ns1__SetFeedback_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SetFeedback_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetFeedback && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SetFeedback(soap, "ns1:SetFeedback", &a->ns1__SetFeedback, ""))
				{	soap_flag_ns1__SetFeedback--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SetFeedback_(struct soap *soap, const struct __ns1__SetFeedback_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__SetFeedback_(soap, tag?tag:"-ns1:SetFeedback", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetFeedback_ * SOAP_FMAC4 soap_get___ns1__SetFeedback_(struct soap *soap, struct __ns1__SetFeedback_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SetFeedback_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__SetFeedback_ * SOAP_FMAC2 soap_instantiate___ns1__SetFeedback_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SetFeedback_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__SetFeedback_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__SetFeedback_);
		if (size)
			*size = sizeof(struct __ns1__SetFeedback_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__SetFeedback_, n);
		if (size)
			*size = n * sizeof(struct __ns1__SetFeedback_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__SetFeedback_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__SetFeedback_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__SetFeedback_ %p -> %p\n", q, p));
	*(struct __ns1__SetFeedback_*)p = *(struct __ns1__SetFeedback_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SetSearchLog_(struct soap *soap, struct __ns1__SetSearchLog_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetSearchLog = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SetSearchLog_(struct soap *soap, const struct __ns1__SetSearchLog_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__SetSearchLog(soap, &a->ns1__SetSearchLog);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SetSearchLog_(struct soap *soap, const char *tag, int id, const struct __ns1__SetSearchLog_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__SetSearchLog(soap, "ns1:SetSearchLog", -1, &a->ns1__SetSearchLog, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetSearchLog_ * SOAP_FMAC4 soap_in___ns1__SetSearchLog_(struct soap *soap, const char *tag, struct __ns1__SetSearchLog_ *a, const char *type)
{
	size_t soap_flag_ns1__SetSearchLog = 1;
	short soap_flag;
	a = (struct __ns1__SetSearchLog_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SetSearchLog_, sizeof(struct __ns1__SetSearchLog_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SetSearchLog_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetSearchLog && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SetSearchLog(soap, "ns1:SetSearchLog", &a->ns1__SetSearchLog, ""))
				{	soap_flag_ns1__SetSearchLog--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SetSearchLog_(struct soap *soap, const struct __ns1__SetSearchLog_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__SetSearchLog_(soap, tag?tag:"-ns1:SetSearchLog", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetSearchLog_ * SOAP_FMAC4 soap_get___ns1__SetSearchLog_(struct soap *soap, struct __ns1__SetSearchLog_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SetSearchLog_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__SetSearchLog_ * SOAP_FMAC2 soap_instantiate___ns1__SetSearchLog_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SetSearchLog_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__SetSearchLog_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__SetSearchLog_);
		if (size)
			*size = sizeof(struct __ns1__SetSearchLog_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__SetSearchLog_, n);
		if (size)
			*size = n * sizeof(struct __ns1__SetSearchLog_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__SetSearchLog_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__SetSearchLog_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__SetSearchLog_ %p -> %p\n", q, p));
	*(struct __ns1__SetSearchLog_*)p = *(struct __ns1__SetSearchLog_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetRandomWord_(struct soap *soap, struct __ns1__GetRandomWord_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetRandomWord = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetRandomWord_(struct soap *soap, const struct __ns1__GetRandomWord_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetRandomWord(soap, &a->ns1__GetRandomWord);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetRandomWord_(struct soap *soap, const char *tag, int id, const struct __ns1__GetRandomWord_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetRandomWord(soap, "ns1:GetRandomWord", -1, &a->ns1__GetRandomWord, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRandomWord_ * SOAP_FMAC4 soap_in___ns1__GetRandomWord_(struct soap *soap, const char *tag, struct __ns1__GetRandomWord_ *a, const char *type)
{
	size_t soap_flag_ns1__GetRandomWord = 1;
	short soap_flag;
	a = (struct __ns1__GetRandomWord_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetRandomWord_, sizeof(struct __ns1__GetRandomWord_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetRandomWord_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetRandomWord && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetRandomWord(soap, "ns1:GetRandomWord", &a->ns1__GetRandomWord, ""))
				{	soap_flag_ns1__GetRandomWord--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetRandomWord_(struct soap *soap, const struct __ns1__GetRandomWord_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetRandomWord_(soap, tag?tag:"-ns1:GetRandomWord", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRandomWord_ * SOAP_FMAC4 soap_get___ns1__GetRandomWord_(struct soap *soap, struct __ns1__GetRandomWord_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetRandomWord_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetRandomWord_ * SOAP_FMAC2 soap_instantiate___ns1__GetRandomWord_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetRandomWord_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetRandomWord_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetRandomWord_);
		if (size)
			*size = sizeof(struct __ns1__GetRandomWord_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetRandomWord_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetRandomWord_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetRandomWord_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetRandomWord_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetRandomWord_ %p -> %p\n", q, p));
	*(struct __ns1__GetRandomWord_*)p = *(struct __ns1__GetRandomWord_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetHotEd2ks_(struct soap *soap, struct __ns1__GetHotEd2ks_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetHotEd2ks = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetHotEd2ks_(struct soap *soap, const struct __ns1__GetHotEd2ks_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetHotEd2ks(soap, &a->ns1__GetHotEd2ks);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetHotEd2ks_(struct soap *soap, const char *tag, int id, const struct __ns1__GetHotEd2ks_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetHotEd2ks(soap, "ns1:GetHotEd2ks", -1, &a->ns1__GetHotEd2ks, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetHotEd2ks_ * SOAP_FMAC4 soap_in___ns1__GetHotEd2ks_(struct soap *soap, const char *tag, struct __ns1__GetHotEd2ks_ *a, const char *type)
{
	size_t soap_flag_ns1__GetHotEd2ks = 1;
	short soap_flag;
	a = (struct __ns1__GetHotEd2ks_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetHotEd2ks_, sizeof(struct __ns1__GetHotEd2ks_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetHotEd2ks_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetHotEd2ks && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetHotEd2ks(soap, "ns1:GetHotEd2ks", &a->ns1__GetHotEd2ks, ""))
				{	soap_flag_ns1__GetHotEd2ks--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetHotEd2ks_(struct soap *soap, const struct __ns1__GetHotEd2ks_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetHotEd2ks_(soap, tag?tag:"-ns1:GetHotEd2ks", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetHotEd2ks_ * SOAP_FMAC4 soap_get___ns1__GetHotEd2ks_(struct soap *soap, struct __ns1__GetHotEd2ks_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetHotEd2ks_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetHotEd2ks_ * SOAP_FMAC2 soap_instantiate___ns1__GetHotEd2ks_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetHotEd2ks_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetHotEd2ks_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetHotEd2ks_);
		if (size)
			*size = sizeof(struct __ns1__GetHotEd2ks_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetHotEd2ks_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetHotEd2ks_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetHotEd2ks_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetHotEd2ks_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetHotEd2ks_ %p -> %p\n", q, p));
	*(struct __ns1__GetHotEd2ks_*)p = *(struct __ns1__GetHotEd2ks_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetHotWords_(struct soap *soap, struct __ns1__GetHotWords_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetHotWords = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetHotWords_(struct soap *soap, const struct __ns1__GetHotWords_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetHotWords(soap, &a->ns1__GetHotWords);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetHotWords_(struct soap *soap, const char *tag, int id, const struct __ns1__GetHotWords_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetHotWords(soap, "ns1:GetHotWords", -1, &a->ns1__GetHotWords, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetHotWords_ * SOAP_FMAC4 soap_in___ns1__GetHotWords_(struct soap *soap, const char *tag, struct __ns1__GetHotWords_ *a, const char *type)
{
	size_t soap_flag_ns1__GetHotWords = 1;
	short soap_flag;
	a = (struct __ns1__GetHotWords_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetHotWords_, sizeof(struct __ns1__GetHotWords_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetHotWords_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetHotWords && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetHotWords(soap, "ns1:GetHotWords", &a->ns1__GetHotWords, ""))
				{	soap_flag_ns1__GetHotWords--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetHotWords_(struct soap *soap, const struct __ns1__GetHotWords_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetHotWords_(soap, tag?tag:"-ns1:GetHotWords", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetHotWords_ * SOAP_FMAC4 soap_get___ns1__GetHotWords_(struct soap *soap, struct __ns1__GetHotWords_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetHotWords_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetHotWords_ * SOAP_FMAC2 soap_instantiate___ns1__GetHotWords_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetHotWords_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetHotWords_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetHotWords_);
		if (size)
			*size = sizeof(struct __ns1__GetHotWords_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetHotWords_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetHotWords_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetHotWords_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetHotWords_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetHotWords_ %p -> %p\n", q, p));
	*(struct __ns1__GetHotWords_*)p = *(struct __ns1__GetHotWords_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetSensitiveWords_(struct soap *soap, struct __ns1__GetSensitiveWords_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetSensitiveWords = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetSensitiveWords_(struct soap *soap, const struct __ns1__GetSensitiveWords_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetSensitiveWords(soap, &a->ns1__GetSensitiveWords);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetSensitiveWords_(struct soap *soap, const char *tag, int id, const struct __ns1__GetSensitiveWords_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetSensitiveWords(soap, "ns1:GetSensitiveWords", -1, &a->ns1__GetSensitiveWords, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetSensitiveWords_ * SOAP_FMAC4 soap_in___ns1__GetSensitiveWords_(struct soap *soap, const char *tag, struct __ns1__GetSensitiveWords_ *a, const char *type)
{
	size_t soap_flag_ns1__GetSensitiveWords = 1;
	short soap_flag;
	a = (struct __ns1__GetSensitiveWords_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetSensitiveWords_, sizeof(struct __ns1__GetSensitiveWords_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetSensitiveWords_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetSensitiveWords && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetSensitiveWords(soap, "ns1:GetSensitiveWords", &a->ns1__GetSensitiveWords, ""))
				{	soap_flag_ns1__GetSensitiveWords--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetSensitiveWords_(struct soap *soap, const struct __ns1__GetSensitiveWords_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetSensitiveWords_(soap, tag?tag:"-ns1:GetSensitiveWords", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetSensitiveWords_ * SOAP_FMAC4 soap_get___ns1__GetSensitiveWords_(struct soap *soap, struct __ns1__GetSensitiveWords_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetSensitiveWords_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetSensitiveWords_ * SOAP_FMAC2 soap_instantiate___ns1__GetSensitiveWords_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetSensitiveWords_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetSensitiveWords_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetSensitiveWords_);
		if (size)
			*size = sizeof(struct __ns1__GetSensitiveWords_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetSensitiveWords_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetSensitiveWords_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetSensitiveWords_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetSensitiveWords_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetSensitiveWords_ %p -> %p\n", q, p));
	*(struct __ns1__GetSensitiveWords_*)p = *(struct __ns1__GetSensitiveWords_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetUserSetting_(struct soap *soap, struct __ns1__GetUserSetting_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetUserSetting = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetUserSetting_(struct soap *soap, const struct __ns1__GetUserSetting_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetUserSetting(soap, &a->ns1__GetUserSetting);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetUserSetting_(struct soap *soap, const char *tag, int id, const struct __ns1__GetUserSetting_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetUserSetting(soap, "ns1:GetUserSetting", -1, &a->ns1__GetUserSetting, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetUserSetting_ * SOAP_FMAC4 soap_in___ns1__GetUserSetting_(struct soap *soap, const char *tag, struct __ns1__GetUserSetting_ *a, const char *type)
{
	size_t soap_flag_ns1__GetUserSetting = 1;
	short soap_flag;
	a = (struct __ns1__GetUserSetting_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetUserSetting_, sizeof(struct __ns1__GetUserSetting_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetUserSetting_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetUserSetting && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetUserSetting(soap, "ns1:GetUserSetting", &a->ns1__GetUserSetting, ""))
				{	soap_flag_ns1__GetUserSetting--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetUserSetting_(struct soap *soap, const struct __ns1__GetUserSetting_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetUserSetting_(soap, tag?tag:"-ns1:GetUserSetting", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetUserSetting_ * SOAP_FMAC4 soap_get___ns1__GetUserSetting_(struct soap *soap, struct __ns1__GetUserSetting_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetUserSetting_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetUserSetting_ * SOAP_FMAC2 soap_instantiate___ns1__GetUserSetting_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetUserSetting_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetUserSetting_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetUserSetting_);
		if (size)
			*size = sizeof(struct __ns1__GetUserSetting_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetUserSetting_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetUserSetting_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetUserSetting_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetUserSetting_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetUserSetting_ %p -> %p\n", q, p));
	*(struct __ns1__GetUserSetting_*)p = *(struct __ns1__GetUserSetting_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetSystemMessage_(struct soap *soap, struct __ns1__GetSystemMessage_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetSystemMessage = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetSystemMessage_(struct soap *soap, const struct __ns1__GetSystemMessage_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetSystemMessage(soap, &a->ns1__GetSystemMessage);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetSystemMessage_(struct soap *soap, const char *tag, int id, const struct __ns1__GetSystemMessage_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetSystemMessage(soap, "ns1:GetSystemMessage", -1, &a->ns1__GetSystemMessage, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetSystemMessage_ * SOAP_FMAC4 soap_in___ns1__GetSystemMessage_(struct soap *soap, const char *tag, struct __ns1__GetSystemMessage_ *a, const char *type)
{
	size_t soap_flag_ns1__GetSystemMessage = 1;
	short soap_flag;
	a = (struct __ns1__GetSystemMessage_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetSystemMessage_, sizeof(struct __ns1__GetSystemMessage_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetSystemMessage_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetSystemMessage && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetSystemMessage(soap, "ns1:GetSystemMessage", &a->ns1__GetSystemMessage, ""))
				{	soap_flag_ns1__GetSystemMessage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetSystemMessage_(struct soap *soap, const struct __ns1__GetSystemMessage_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetSystemMessage_(soap, tag?tag:"-ns1:GetSystemMessage", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetSystemMessage_ * SOAP_FMAC4 soap_get___ns1__GetSystemMessage_(struct soap *soap, struct __ns1__GetSystemMessage_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetSystemMessage_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetSystemMessage_ * SOAP_FMAC2 soap_instantiate___ns1__GetSystemMessage_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetSystemMessage_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetSystemMessage_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetSystemMessage_);
		if (size)
			*size = sizeof(struct __ns1__GetSystemMessage_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetSystemMessage_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetSystemMessage_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetSystemMessage_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetSystemMessage_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetSystemMessage_ %p -> %p\n", q, p));
	*(struct __ns1__GetSystemMessage_*)p = *(struct __ns1__GetSystemMessage_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetSystemNotify_(struct soap *soap, struct __ns1__GetSystemNotify_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetSystemNotify = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetSystemNotify_(struct soap *soap, const struct __ns1__GetSystemNotify_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetSystemNotify(soap, &a->ns1__GetSystemNotify);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetSystemNotify_(struct soap *soap, const char *tag, int id, const struct __ns1__GetSystemNotify_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetSystemNotify(soap, "ns1:GetSystemNotify", -1, &a->ns1__GetSystemNotify, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetSystemNotify_ * SOAP_FMAC4 soap_in___ns1__GetSystemNotify_(struct soap *soap, const char *tag, struct __ns1__GetSystemNotify_ *a, const char *type)
{
	size_t soap_flag_ns1__GetSystemNotify = 1;
	short soap_flag;
	a = (struct __ns1__GetSystemNotify_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetSystemNotify_, sizeof(struct __ns1__GetSystemNotify_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetSystemNotify_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetSystemNotify && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetSystemNotify(soap, "ns1:GetSystemNotify", &a->ns1__GetSystemNotify, ""))
				{	soap_flag_ns1__GetSystemNotify--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetSystemNotify_(struct soap *soap, const struct __ns1__GetSystemNotify_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetSystemNotify_(soap, tag?tag:"-ns1:GetSystemNotify", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetSystemNotify_ * SOAP_FMAC4 soap_get___ns1__GetSystemNotify_(struct soap *soap, struct __ns1__GetSystemNotify_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetSystemNotify_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetSystemNotify_ * SOAP_FMAC2 soap_instantiate___ns1__GetSystemNotify_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetSystemNotify_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetSystemNotify_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetSystemNotify_);
		if (size)
			*size = sizeof(struct __ns1__GetSystemNotify_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetSystemNotify_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetSystemNotify_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetSystemNotify_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetSystemNotify_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetSystemNotify_ %p -> %p\n", q, p));
	*(struct __ns1__GetSystemNotify_*)p = *(struct __ns1__GetSystemNotify_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SetPlayLog(struct soap *soap, struct __ns1__SetPlayLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetPlayLog = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SetPlayLog(struct soap *soap, const struct __ns1__SetPlayLog *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__SetPlayLog(soap, &a->ns1__SetPlayLog);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SetPlayLog(struct soap *soap, const char *tag, int id, const struct __ns1__SetPlayLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__SetPlayLog(soap, "ns1:SetPlayLog", -1, &a->ns1__SetPlayLog, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetPlayLog * SOAP_FMAC4 soap_in___ns1__SetPlayLog(struct soap *soap, const char *tag, struct __ns1__SetPlayLog *a, const char *type)
{
	size_t soap_flag_ns1__SetPlayLog = 1;
	short soap_flag;
	a = (struct __ns1__SetPlayLog *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SetPlayLog, sizeof(struct __ns1__SetPlayLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SetPlayLog(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetPlayLog && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SetPlayLog(soap, "ns1:SetPlayLog", &a->ns1__SetPlayLog, ""))
				{	soap_flag_ns1__SetPlayLog--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SetPlayLog(struct soap *soap, const struct __ns1__SetPlayLog *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__SetPlayLog(soap, tag?tag:"-ns1:SetPlayLog", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetPlayLog * SOAP_FMAC4 soap_get___ns1__SetPlayLog(struct soap *soap, struct __ns1__SetPlayLog *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SetPlayLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__SetPlayLog * SOAP_FMAC2 soap_instantiate___ns1__SetPlayLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SetPlayLog(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__SetPlayLog, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__SetPlayLog);
		if (size)
			*size = sizeof(struct __ns1__SetPlayLog);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__SetPlayLog, n);
		if (size)
			*size = n * sizeof(struct __ns1__SetPlayLog);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__SetPlayLog*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__SetPlayLog(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__SetPlayLog %p -> %p\n", q, p));
	*(struct __ns1__SetPlayLog*)p = *(struct __ns1__SetPlayLog*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SetFeedback(struct soap *soap, struct __ns1__SetFeedback *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetFeedback = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SetFeedback(struct soap *soap, const struct __ns1__SetFeedback *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__SetFeedback(soap, &a->ns1__SetFeedback);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SetFeedback(struct soap *soap, const char *tag, int id, const struct __ns1__SetFeedback *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__SetFeedback(soap, "ns1:SetFeedback", -1, &a->ns1__SetFeedback, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetFeedback * SOAP_FMAC4 soap_in___ns1__SetFeedback(struct soap *soap, const char *tag, struct __ns1__SetFeedback *a, const char *type)
{
	size_t soap_flag_ns1__SetFeedback = 1;
	short soap_flag;
	a = (struct __ns1__SetFeedback *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SetFeedback, sizeof(struct __ns1__SetFeedback), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SetFeedback(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetFeedback && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SetFeedback(soap, "ns1:SetFeedback", &a->ns1__SetFeedback, ""))
				{	soap_flag_ns1__SetFeedback--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SetFeedback(struct soap *soap, const struct __ns1__SetFeedback *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__SetFeedback(soap, tag?tag:"-ns1:SetFeedback", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetFeedback * SOAP_FMAC4 soap_get___ns1__SetFeedback(struct soap *soap, struct __ns1__SetFeedback *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SetFeedback(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__SetFeedback * SOAP_FMAC2 soap_instantiate___ns1__SetFeedback(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SetFeedback(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__SetFeedback, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__SetFeedback);
		if (size)
			*size = sizeof(struct __ns1__SetFeedback);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__SetFeedback, n);
		if (size)
			*size = n * sizeof(struct __ns1__SetFeedback);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__SetFeedback*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__SetFeedback(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__SetFeedback %p -> %p\n", q, p));
	*(struct __ns1__SetFeedback*)p = *(struct __ns1__SetFeedback*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SetSearchLog(struct soap *soap, struct __ns1__SetSearchLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetSearchLog = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SetSearchLog(struct soap *soap, const struct __ns1__SetSearchLog *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__SetSearchLog(soap, &a->ns1__SetSearchLog);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SetSearchLog(struct soap *soap, const char *tag, int id, const struct __ns1__SetSearchLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__SetSearchLog(soap, "ns1:SetSearchLog", -1, &a->ns1__SetSearchLog, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetSearchLog * SOAP_FMAC4 soap_in___ns1__SetSearchLog(struct soap *soap, const char *tag, struct __ns1__SetSearchLog *a, const char *type)
{
	size_t soap_flag_ns1__SetSearchLog = 1;
	short soap_flag;
	a = (struct __ns1__SetSearchLog *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SetSearchLog, sizeof(struct __ns1__SetSearchLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SetSearchLog(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetSearchLog && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SetSearchLog(soap, "ns1:SetSearchLog", &a->ns1__SetSearchLog, ""))
				{	soap_flag_ns1__SetSearchLog--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SetSearchLog(struct soap *soap, const struct __ns1__SetSearchLog *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__SetSearchLog(soap, tag?tag:"-ns1:SetSearchLog", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetSearchLog * SOAP_FMAC4 soap_get___ns1__SetSearchLog(struct soap *soap, struct __ns1__SetSearchLog *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SetSearchLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__SetSearchLog * SOAP_FMAC2 soap_instantiate___ns1__SetSearchLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SetSearchLog(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__SetSearchLog, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__SetSearchLog);
		if (size)
			*size = sizeof(struct __ns1__SetSearchLog);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__SetSearchLog, n);
		if (size)
			*size = n * sizeof(struct __ns1__SetSearchLog);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__SetSearchLog*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__SetSearchLog(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__SetSearchLog %p -> %p\n", q, p));
	*(struct __ns1__SetSearchLog*)p = *(struct __ns1__SetSearchLog*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetRandomWord(struct soap *soap, struct __ns1__GetRandomWord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetRandomWord = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetRandomWord(struct soap *soap, const struct __ns1__GetRandomWord *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetRandomWord(soap, &a->ns1__GetRandomWord);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetRandomWord(struct soap *soap, const char *tag, int id, const struct __ns1__GetRandomWord *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetRandomWord(soap, "ns1:GetRandomWord", -1, &a->ns1__GetRandomWord, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRandomWord * SOAP_FMAC4 soap_in___ns1__GetRandomWord(struct soap *soap, const char *tag, struct __ns1__GetRandomWord *a, const char *type)
{
	size_t soap_flag_ns1__GetRandomWord = 1;
	short soap_flag;
	a = (struct __ns1__GetRandomWord *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetRandomWord, sizeof(struct __ns1__GetRandomWord), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetRandomWord(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetRandomWord && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetRandomWord(soap, "ns1:GetRandomWord", &a->ns1__GetRandomWord, ""))
				{	soap_flag_ns1__GetRandomWord--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetRandomWord(struct soap *soap, const struct __ns1__GetRandomWord *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetRandomWord(soap, tag?tag:"-ns1:GetRandomWord", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetRandomWord * SOAP_FMAC4 soap_get___ns1__GetRandomWord(struct soap *soap, struct __ns1__GetRandomWord *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetRandomWord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetRandomWord * SOAP_FMAC2 soap_instantiate___ns1__GetRandomWord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetRandomWord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetRandomWord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetRandomWord);
		if (size)
			*size = sizeof(struct __ns1__GetRandomWord);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetRandomWord, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetRandomWord);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetRandomWord*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetRandomWord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetRandomWord %p -> %p\n", q, p));
	*(struct __ns1__GetRandomWord*)p = *(struct __ns1__GetRandomWord*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetHotEd2ks(struct soap *soap, struct __ns1__GetHotEd2ks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetHotEd2ks = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetHotEd2ks(struct soap *soap, const struct __ns1__GetHotEd2ks *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetHotEd2ks(soap, &a->ns1__GetHotEd2ks);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetHotEd2ks(struct soap *soap, const char *tag, int id, const struct __ns1__GetHotEd2ks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetHotEd2ks(soap, "ns1:GetHotEd2ks", -1, &a->ns1__GetHotEd2ks, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetHotEd2ks * SOAP_FMAC4 soap_in___ns1__GetHotEd2ks(struct soap *soap, const char *tag, struct __ns1__GetHotEd2ks *a, const char *type)
{
	size_t soap_flag_ns1__GetHotEd2ks = 1;
	short soap_flag;
	a = (struct __ns1__GetHotEd2ks *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetHotEd2ks, sizeof(struct __ns1__GetHotEd2ks), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetHotEd2ks(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetHotEd2ks && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetHotEd2ks(soap, "ns1:GetHotEd2ks", &a->ns1__GetHotEd2ks, ""))
				{	soap_flag_ns1__GetHotEd2ks--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetHotEd2ks(struct soap *soap, const struct __ns1__GetHotEd2ks *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetHotEd2ks(soap, tag?tag:"-ns1:GetHotEd2ks", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetHotEd2ks * SOAP_FMAC4 soap_get___ns1__GetHotEd2ks(struct soap *soap, struct __ns1__GetHotEd2ks *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetHotEd2ks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetHotEd2ks * SOAP_FMAC2 soap_instantiate___ns1__GetHotEd2ks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetHotEd2ks(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetHotEd2ks, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetHotEd2ks);
		if (size)
			*size = sizeof(struct __ns1__GetHotEd2ks);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetHotEd2ks, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetHotEd2ks);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetHotEd2ks*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetHotEd2ks(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetHotEd2ks %p -> %p\n", q, p));
	*(struct __ns1__GetHotEd2ks*)p = *(struct __ns1__GetHotEd2ks*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetHotWords(struct soap *soap, struct __ns1__GetHotWords *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetHotWords = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetHotWords(struct soap *soap, const struct __ns1__GetHotWords *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetHotWords(soap, &a->ns1__GetHotWords);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetHotWords(struct soap *soap, const char *tag, int id, const struct __ns1__GetHotWords *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetHotWords(soap, "ns1:GetHotWords", -1, &a->ns1__GetHotWords, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetHotWords * SOAP_FMAC4 soap_in___ns1__GetHotWords(struct soap *soap, const char *tag, struct __ns1__GetHotWords *a, const char *type)
{
	size_t soap_flag_ns1__GetHotWords = 1;
	short soap_flag;
	a = (struct __ns1__GetHotWords *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetHotWords, sizeof(struct __ns1__GetHotWords), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetHotWords(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetHotWords && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetHotWords(soap, "ns1:GetHotWords", &a->ns1__GetHotWords, ""))
				{	soap_flag_ns1__GetHotWords--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetHotWords(struct soap *soap, const struct __ns1__GetHotWords *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetHotWords(soap, tag?tag:"-ns1:GetHotWords", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetHotWords * SOAP_FMAC4 soap_get___ns1__GetHotWords(struct soap *soap, struct __ns1__GetHotWords *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetHotWords(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetHotWords * SOAP_FMAC2 soap_instantiate___ns1__GetHotWords(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetHotWords(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetHotWords, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetHotWords);
		if (size)
			*size = sizeof(struct __ns1__GetHotWords);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetHotWords, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetHotWords);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetHotWords*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetHotWords(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetHotWords %p -> %p\n", q, p));
	*(struct __ns1__GetHotWords*)p = *(struct __ns1__GetHotWords*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetSensitiveWords(struct soap *soap, struct __ns1__GetSensitiveWords *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetSensitiveWords = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetSensitiveWords(struct soap *soap, const struct __ns1__GetSensitiveWords *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetSensitiveWords(soap, &a->ns1__GetSensitiveWords);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetSensitiveWords(struct soap *soap, const char *tag, int id, const struct __ns1__GetSensitiveWords *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetSensitiveWords(soap, "ns1:GetSensitiveWords", -1, &a->ns1__GetSensitiveWords, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetSensitiveWords * SOAP_FMAC4 soap_in___ns1__GetSensitiveWords(struct soap *soap, const char *tag, struct __ns1__GetSensitiveWords *a, const char *type)
{
	size_t soap_flag_ns1__GetSensitiveWords = 1;
	short soap_flag;
	a = (struct __ns1__GetSensitiveWords *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetSensitiveWords, sizeof(struct __ns1__GetSensitiveWords), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetSensitiveWords(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetSensitiveWords && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetSensitiveWords(soap, "ns1:GetSensitiveWords", &a->ns1__GetSensitiveWords, ""))
				{	soap_flag_ns1__GetSensitiveWords--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetSensitiveWords(struct soap *soap, const struct __ns1__GetSensitiveWords *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetSensitiveWords(soap, tag?tag:"-ns1:GetSensitiveWords", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetSensitiveWords * SOAP_FMAC4 soap_get___ns1__GetSensitiveWords(struct soap *soap, struct __ns1__GetSensitiveWords *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetSensitiveWords(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetSensitiveWords * SOAP_FMAC2 soap_instantiate___ns1__GetSensitiveWords(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetSensitiveWords(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetSensitiveWords, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetSensitiveWords);
		if (size)
			*size = sizeof(struct __ns1__GetSensitiveWords);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetSensitiveWords, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetSensitiveWords);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetSensitiveWords*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetSensitiveWords(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetSensitiveWords %p -> %p\n", q, p));
	*(struct __ns1__GetSensitiveWords*)p = *(struct __ns1__GetSensitiveWords*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetUserSetting(struct soap *soap, struct __ns1__GetUserSetting *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetUserSetting = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetUserSetting(struct soap *soap, const struct __ns1__GetUserSetting *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetUserSetting(soap, &a->ns1__GetUserSetting);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetUserSetting(struct soap *soap, const char *tag, int id, const struct __ns1__GetUserSetting *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetUserSetting(soap, "ns1:GetUserSetting", -1, &a->ns1__GetUserSetting, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetUserSetting * SOAP_FMAC4 soap_in___ns1__GetUserSetting(struct soap *soap, const char *tag, struct __ns1__GetUserSetting *a, const char *type)
{
	size_t soap_flag_ns1__GetUserSetting = 1;
	short soap_flag;
	a = (struct __ns1__GetUserSetting *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetUserSetting, sizeof(struct __ns1__GetUserSetting), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetUserSetting(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetUserSetting && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetUserSetting(soap, "ns1:GetUserSetting", &a->ns1__GetUserSetting, ""))
				{	soap_flag_ns1__GetUserSetting--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetUserSetting(struct soap *soap, const struct __ns1__GetUserSetting *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetUserSetting(soap, tag?tag:"-ns1:GetUserSetting", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetUserSetting * SOAP_FMAC4 soap_get___ns1__GetUserSetting(struct soap *soap, struct __ns1__GetUserSetting *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetUserSetting(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetUserSetting * SOAP_FMAC2 soap_instantiate___ns1__GetUserSetting(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetUserSetting(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetUserSetting, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetUserSetting);
		if (size)
			*size = sizeof(struct __ns1__GetUserSetting);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetUserSetting, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetUserSetting);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetUserSetting*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetUserSetting(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetUserSetting %p -> %p\n", q, p));
	*(struct __ns1__GetUserSetting*)p = *(struct __ns1__GetUserSetting*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetSystemMessage(struct soap *soap, struct __ns1__GetSystemMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetSystemMessage = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetSystemMessage(struct soap *soap, const struct __ns1__GetSystemMessage *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetSystemMessage(soap, &a->ns1__GetSystemMessage);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetSystemMessage(struct soap *soap, const char *tag, int id, const struct __ns1__GetSystemMessage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetSystemMessage(soap, "ns1:GetSystemMessage", -1, &a->ns1__GetSystemMessage, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetSystemMessage * SOAP_FMAC4 soap_in___ns1__GetSystemMessage(struct soap *soap, const char *tag, struct __ns1__GetSystemMessage *a, const char *type)
{
	size_t soap_flag_ns1__GetSystemMessage = 1;
	short soap_flag;
	a = (struct __ns1__GetSystemMessage *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetSystemMessage, sizeof(struct __ns1__GetSystemMessage), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetSystemMessage(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetSystemMessage && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetSystemMessage(soap, "ns1:GetSystemMessage", &a->ns1__GetSystemMessage, ""))
				{	soap_flag_ns1__GetSystemMessage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetSystemMessage(struct soap *soap, const struct __ns1__GetSystemMessage *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetSystemMessage(soap, tag?tag:"-ns1:GetSystemMessage", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetSystemMessage * SOAP_FMAC4 soap_get___ns1__GetSystemMessage(struct soap *soap, struct __ns1__GetSystemMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetSystemMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetSystemMessage * SOAP_FMAC2 soap_instantiate___ns1__GetSystemMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetSystemMessage(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetSystemMessage, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetSystemMessage);
		if (size)
			*size = sizeof(struct __ns1__GetSystemMessage);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetSystemMessage, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetSystemMessage);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetSystemMessage*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetSystemMessage(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetSystemMessage %p -> %p\n", q, p));
	*(struct __ns1__GetSystemMessage*)p = *(struct __ns1__GetSystemMessage*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetSystemNotify(struct soap *soap, struct __ns1__GetSystemNotify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetSystemNotify = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetSystemNotify(struct soap *soap, const struct __ns1__GetSystemNotify *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetSystemNotify(soap, &a->ns1__GetSystemNotify);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetSystemNotify(struct soap *soap, const char *tag, int id, const struct __ns1__GetSystemNotify *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetSystemNotify(soap, "ns1:GetSystemNotify", -1, &a->ns1__GetSystemNotify, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetSystemNotify * SOAP_FMAC4 soap_in___ns1__GetSystemNotify(struct soap *soap, const char *tag, struct __ns1__GetSystemNotify *a, const char *type)
{
	size_t soap_flag_ns1__GetSystemNotify = 1;
	short soap_flag;
	a = (struct __ns1__GetSystemNotify *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetSystemNotify, sizeof(struct __ns1__GetSystemNotify), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetSystemNotify(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetSystemNotify && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetSystemNotify(soap, "ns1:GetSystemNotify", &a->ns1__GetSystemNotify, ""))
				{	soap_flag_ns1__GetSystemNotify--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetSystemNotify(struct soap *soap, const struct __ns1__GetSystemNotify *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetSystemNotify(soap, tag?tag:"-ns1:GetSystemNotify", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetSystemNotify * SOAP_FMAC4 soap_get___ns1__GetSystemNotify(struct soap *soap, struct __ns1__GetSystemNotify *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetSystemNotify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetSystemNotify * SOAP_FMAC2 soap_instantiate___ns1__GetSystemNotify(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetSystemNotify(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetSystemNotify, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetSystemNotify);
		if (size)
			*size = sizeof(struct __ns1__GetSystemNotify);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetSystemNotify, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetSystemNotify);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetSystemNotify*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetSystemNotify(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetSystemNotify %p -> %p\n", q, p));
	*(struct __ns1__GetSystemNotify*)p = *(struct __ns1__GetSystemNotify*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetPlayLogResponse(struct soap *soap, _ns1__SetPlayLogResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetPlayLogResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetPlayLogResponse(struct soap *soap, const char *tag, int id, _ns1__SetPlayLogResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetPlayLogResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SetPlayLogResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetPlayLogResponse(struct soap *soap, const char *tag, _ns1__SetPlayLogResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetPlayLogResponse **)soap_malloc(soap, sizeof(_ns1__SetPlayLogResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetPlayLogResponse *)soap_instantiate__ns1__SetPlayLogResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SetPlayLogResponse ** p = (_ns1__SetPlayLogResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetPlayLogResponse, sizeof(_ns1__SetPlayLogResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetPlayLogResponse(struct soap *soap, _ns1__SetPlayLogResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SetPlayLogResponse);
	if (soap_out_PointerTo_ns1__SetPlayLogResponse(soap, tag?tag:"ns1:SetPlayLogResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SetPlayLogResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetPlayLogResponse(struct soap *soap, _ns1__SetPlayLogResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetPlayLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetPlayLog(struct soap *soap, _ns1__SetPlayLog *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetPlayLog))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetPlayLog(struct soap *soap, const char *tag, int id, _ns1__SetPlayLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetPlayLog);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SetPlayLog ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetPlayLog(struct soap *soap, const char *tag, _ns1__SetPlayLog **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetPlayLog **)soap_malloc(soap, sizeof(_ns1__SetPlayLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetPlayLog *)soap_instantiate__ns1__SetPlayLog(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SetPlayLog ** p = (_ns1__SetPlayLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetPlayLog, sizeof(_ns1__SetPlayLog), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetPlayLog(struct soap *soap, _ns1__SetPlayLog *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SetPlayLog);
	if (soap_out_PointerTo_ns1__SetPlayLog(soap, tag?tag:"ns1:SetPlayLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SetPlayLog ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetPlayLog(struct soap *soap, _ns1__SetPlayLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetPlayLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetFeedbackResponse(struct soap *soap, _ns1__SetFeedbackResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetFeedbackResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetFeedbackResponse(struct soap *soap, const char *tag, int id, _ns1__SetFeedbackResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetFeedbackResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SetFeedbackResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetFeedbackResponse(struct soap *soap, const char *tag, _ns1__SetFeedbackResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetFeedbackResponse **)soap_malloc(soap, sizeof(_ns1__SetFeedbackResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetFeedbackResponse *)soap_instantiate__ns1__SetFeedbackResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SetFeedbackResponse ** p = (_ns1__SetFeedbackResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetFeedbackResponse, sizeof(_ns1__SetFeedbackResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetFeedbackResponse(struct soap *soap, _ns1__SetFeedbackResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SetFeedbackResponse);
	if (soap_out_PointerTo_ns1__SetFeedbackResponse(soap, tag?tag:"ns1:SetFeedbackResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SetFeedbackResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetFeedbackResponse(struct soap *soap, _ns1__SetFeedbackResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetFeedbackResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetFeedback(struct soap *soap, _ns1__SetFeedback *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetFeedback))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetFeedback(struct soap *soap, const char *tag, int id, _ns1__SetFeedback *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetFeedback);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SetFeedback ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetFeedback(struct soap *soap, const char *tag, _ns1__SetFeedback **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetFeedback **)soap_malloc(soap, sizeof(_ns1__SetFeedback *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetFeedback *)soap_instantiate__ns1__SetFeedback(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SetFeedback ** p = (_ns1__SetFeedback **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetFeedback, sizeof(_ns1__SetFeedback), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetFeedback(struct soap *soap, _ns1__SetFeedback *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SetFeedback);
	if (soap_out_PointerTo_ns1__SetFeedback(soap, tag?tag:"ns1:SetFeedback", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SetFeedback ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetFeedback(struct soap *soap, _ns1__SetFeedback **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetFeedback(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetSearchLogResponse(struct soap *soap, _ns1__SetSearchLogResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetSearchLogResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetSearchLogResponse(struct soap *soap, const char *tag, int id, _ns1__SetSearchLogResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetSearchLogResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SetSearchLogResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetSearchLogResponse(struct soap *soap, const char *tag, _ns1__SetSearchLogResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetSearchLogResponse **)soap_malloc(soap, sizeof(_ns1__SetSearchLogResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetSearchLogResponse *)soap_instantiate__ns1__SetSearchLogResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SetSearchLogResponse ** p = (_ns1__SetSearchLogResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetSearchLogResponse, sizeof(_ns1__SetSearchLogResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetSearchLogResponse(struct soap *soap, _ns1__SetSearchLogResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SetSearchLogResponse);
	if (soap_out_PointerTo_ns1__SetSearchLogResponse(soap, tag?tag:"ns1:SetSearchLogResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SetSearchLogResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetSearchLogResponse(struct soap *soap, _ns1__SetSearchLogResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetSearchLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetSearchLog(struct soap *soap, _ns1__SetSearchLog *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetSearchLog))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetSearchLog(struct soap *soap, const char *tag, int id, _ns1__SetSearchLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetSearchLog);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SetSearchLog ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetSearchLog(struct soap *soap, const char *tag, _ns1__SetSearchLog **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetSearchLog **)soap_malloc(soap, sizeof(_ns1__SetSearchLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetSearchLog *)soap_instantiate__ns1__SetSearchLog(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SetSearchLog ** p = (_ns1__SetSearchLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetSearchLog, sizeof(_ns1__SetSearchLog), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetSearchLog(struct soap *soap, _ns1__SetSearchLog *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SetSearchLog);
	if (soap_out_PointerTo_ns1__SetSearchLog(soap, tag?tag:"ns1:SetSearchLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SetSearchLog ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetSearchLog(struct soap *soap, _ns1__SetSearchLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetSearchLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetRandomWordResponse(struct soap *soap, _ns1__GetRandomWordResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetRandomWordResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetRandomWordResponse(struct soap *soap, const char *tag, int id, _ns1__GetRandomWordResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetRandomWordResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetRandomWordResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetRandomWordResponse(struct soap *soap, const char *tag, _ns1__GetRandomWordResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetRandomWordResponse **)soap_malloc(soap, sizeof(_ns1__GetRandomWordResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetRandomWordResponse *)soap_instantiate__ns1__GetRandomWordResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetRandomWordResponse ** p = (_ns1__GetRandomWordResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetRandomWordResponse, sizeof(_ns1__GetRandomWordResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetRandomWordResponse(struct soap *soap, _ns1__GetRandomWordResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetRandomWordResponse);
	if (soap_out_PointerTo_ns1__GetRandomWordResponse(soap, tag?tag:"ns1:GetRandomWordResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetRandomWordResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetRandomWordResponse(struct soap *soap, _ns1__GetRandomWordResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetRandomWordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetRandomWord(struct soap *soap, _ns1__GetRandomWord *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetRandomWord))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetRandomWord(struct soap *soap, const char *tag, int id, _ns1__GetRandomWord *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetRandomWord);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetRandomWord ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetRandomWord(struct soap *soap, const char *tag, _ns1__GetRandomWord **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetRandomWord **)soap_malloc(soap, sizeof(_ns1__GetRandomWord *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetRandomWord *)soap_instantiate__ns1__GetRandomWord(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetRandomWord ** p = (_ns1__GetRandomWord **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetRandomWord, sizeof(_ns1__GetRandomWord), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetRandomWord(struct soap *soap, _ns1__GetRandomWord *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetRandomWord);
	if (soap_out_PointerTo_ns1__GetRandomWord(soap, tag?tag:"ns1:GetRandomWord", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetRandomWord ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetRandomWord(struct soap *soap, _ns1__GetRandomWord **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetRandomWord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetHotEd2ksResponse(struct soap *soap, _ns1__GetHotEd2ksResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetHotEd2ksResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetHotEd2ksResponse(struct soap *soap, const char *tag, int id, _ns1__GetHotEd2ksResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetHotEd2ksResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetHotEd2ksResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetHotEd2ksResponse(struct soap *soap, const char *tag, _ns1__GetHotEd2ksResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetHotEd2ksResponse **)soap_malloc(soap, sizeof(_ns1__GetHotEd2ksResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetHotEd2ksResponse *)soap_instantiate__ns1__GetHotEd2ksResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetHotEd2ksResponse ** p = (_ns1__GetHotEd2ksResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetHotEd2ksResponse, sizeof(_ns1__GetHotEd2ksResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetHotEd2ksResponse(struct soap *soap, _ns1__GetHotEd2ksResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetHotEd2ksResponse);
	if (soap_out_PointerTo_ns1__GetHotEd2ksResponse(soap, tag?tag:"ns1:GetHotEd2ksResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetHotEd2ksResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetHotEd2ksResponse(struct soap *soap, _ns1__GetHotEd2ksResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetHotEd2ksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetHotEd2ks(struct soap *soap, _ns1__GetHotEd2ks *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetHotEd2ks))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetHotEd2ks(struct soap *soap, const char *tag, int id, _ns1__GetHotEd2ks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetHotEd2ks);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetHotEd2ks ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetHotEd2ks(struct soap *soap, const char *tag, _ns1__GetHotEd2ks **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetHotEd2ks **)soap_malloc(soap, sizeof(_ns1__GetHotEd2ks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetHotEd2ks *)soap_instantiate__ns1__GetHotEd2ks(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetHotEd2ks ** p = (_ns1__GetHotEd2ks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetHotEd2ks, sizeof(_ns1__GetHotEd2ks), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetHotEd2ks(struct soap *soap, _ns1__GetHotEd2ks *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetHotEd2ks);
	if (soap_out_PointerTo_ns1__GetHotEd2ks(soap, tag?tag:"ns1:GetHotEd2ks", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetHotEd2ks ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetHotEd2ks(struct soap *soap, _ns1__GetHotEd2ks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetHotEd2ks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetHotWordsResponse(struct soap *soap, _ns1__GetHotWordsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetHotWordsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetHotWordsResponse(struct soap *soap, const char *tag, int id, _ns1__GetHotWordsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetHotWordsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetHotWordsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetHotWordsResponse(struct soap *soap, const char *tag, _ns1__GetHotWordsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetHotWordsResponse **)soap_malloc(soap, sizeof(_ns1__GetHotWordsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetHotWordsResponse *)soap_instantiate__ns1__GetHotWordsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetHotWordsResponse ** p = (_ns1__GetHotWordsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetHotWordsResponse, sizeof(_ns1__GetHotWordsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetHotWordsResponse(struct soap *soap, _ns1__GetHotWordsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetHotWordsResponse);
	if (soap_out_PointerTo_ns1__GetHotWordsResponse(soap, tag?tag:"ns1:GetHotWordsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetHotWordsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetHotWordsResponse(struct soap *soap, _ns1__GetHotWordsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetHotWordsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetHotWords(struct soap *soap, _ns1__GetHotWords *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetHotWords))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetHotWords(struct soap *soap, const char *tag, int id, _ns1__GetHotWords *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetHotWords);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetHotWords ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetHotWords(struct soap *soap, const char *tag, _ns1__GetHotWords **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetHotWords **)soap_malloc(soap, sizeof(_ns1__GetHotWords *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetHotWords *)soap_instantiate__ns1__GetHotWords(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetHotWords ** p = (_ns1__GetHotWords **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetHotWords, sizeof(_ns1__GetHotWords), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetHotWords(struct soap *soap, _ns1__GetHotWords *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetHotWords);
	if (soap_out_PointerTo_ns1__GetHotWords(soap, tag?tag:"ns1:GetHotWords", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetHotWords ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetHotWords(struct soap *soap, _ns1__GetHotWords **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetHotWords(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetSensitiveWordsResponse(struct soap *soap, _ns1__GetSensitiveWordsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetSensitiveWordsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetSensitiveWordsResponse(struct soap *soap, const char *tag, int id, _ns1__GetSensitiveWordsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetSensitiveWordsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetSensitiveWordsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetSensitiveWordsResponse(struct soap *soap, const char *tag, _ns1__GetSensitiveWordsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetSensitiveWordsResponse **)soap_malloc(soap, sizeof(_ns1__GetSensitiveWordsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetSensitiveWordsResponse *)soap_instantiate__ns1__GetSensitiveWordsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetSensitiveWordsResponse ** p = (_ns1__GetSensitiveWordsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetSensitiveWordsResponse, sizeof(_ns1__GetSensitiveWordsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetSensitiveWordsResponse(struct soap *soap, _ns1__GetSensitiveWordsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetSensitiveWordsResponse);
	if (soap_out_PointerTo_ns1__GetSensitiveWordsResponse(soap, tag?tag:"ns1:GetSensitiveWordsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetSensitiveWordsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetSensitiveWordsResponse(struct soap *soap, _ns1__GetSensitiveWordsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetSensitiveWordsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetSensitiveWords(struct soap *soap, _ns1__GetSensitiveWords *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetSensitiveWords))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetSensitiveWords(struct soap *soap, const char *tag, int id, _ns1__GetSensitiveWords *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetSensitiveWords);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetSensitiveWords ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetSensitiveWords(struct soap *soap, const char *tag, _ns1__GetSensitiveWords **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetSensitiveWords **)soap_malloc(soap, sizeof(_ns1__GetSensitiveWords *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetSensitiveWords *)soap_instantiate__ns1__GetSensitiveWords(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetSensitiveWords ** p = (_ns1__GetSensitiveWords **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetSensitiveWords, sizeof(_ns1__GetSensitiveWords), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetSensitiveWords(struct soap *soap, _ns1__GetSensitiveWords *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetSensitiveWords);
	if (soap_out_PointerTo_ns1__GetSensitiveWords(soap, tag?tag:"ns1:GetSensitiveWords", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetSensitiveWords ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetSensitiveWords(struct soap *soap, _ns1__GetSensitiveWords **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetSensitiveWords(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetUserSettingResponse(struct soap *soap, _ns1__GetUserSettingResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetUserSettingResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetUserSettingResponse(struct soap *soap, const char *tag, int id, _ns1__GetUserSettingResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetUserSettingResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetUserSettingResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetUserSettingResponse(struct soap *soap, const char *tag, _ns1__GetUserSettingResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetUserSettingResponse **)soap_malloc(soap, sizeof(_ns1__GetUserSettingResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetUserSettingResponse *)soap_instantiate__ns1__GetUserSettingResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetUserSettingResponse ** p = (_ns1__GetUserSettingResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetUserSettingResponse, sizeof(_ns1__GetUserSettingResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetUserSettingResponse(struct soap *soap, _ns1__GetUserSettingResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetUserSettingResponse);
	if (soap_out_PointerTo_ns1__GetUserSettingResponse(soap, tag?tag:"ns1:GetUserSettingResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetUserSettingResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetUserSettingResponse(struct soap *soap, _ns1__GetUserSettingResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetUserSettingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetUserSetting(struct soap *soap, _ns1__GetUserSetting *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetUserSetting))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetUserSetting(struct soap *soap, const char *tag, int id, _ns1__GetUserSetting *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetUserSetting);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetUserSetting ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetUserSetting(struct soap *soap, const char *tag, _ns1__GetUserSetting **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetUserSetting **)soap_malloc(soap, sizeof(_ns1__GetUserSetting *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetUserSetting *)soap_instantiate__ns1__GetUserSetting(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetUserSetting ** p = (_ns1__GetUserSetting **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetUserSetting, sizeof(_ns1__GetUserSetting), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetUserSetting(struct soap *soap, _ns1__GetUserSetting *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetUserSetting);
	if (soap_out_PointerTo_ns1__GetUserSetting(soap, tag?tag:"ns1:GetUserSetting", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetUserSetting ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetUserSetting(struct soap *soap, _ns1__GetUserSetting **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetUserSetting(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetSystemMessageResponse(struct soap *soap, _ns1__GetSystemMessageResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetSystemMessageResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetSystemMessageResponse(struct soap *soap, const char *tag, int id, _ns1__GetSystemMessageResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetSystemMessageResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetSystemMessageResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetSystemMessageResponse(struct soap *soap, const char *tag, _ns1__GetSystemMessageResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetSystemMessageResponse **)soap_malloc(soap, sizeof(_ns1__GetSystemMessageResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetSystemMessageResponse *)soap_instantiate__ns1__GetSystemMessageResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetSystemMessageResponse ** p = (_ns1__GetSystemMessageResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetSystemMessageResponse, sizeof(_ns1__GetSystemMessageResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetSystemMessageResponse(struct soap *soap, _ns1__GetSystemMessageResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetSystemMessageResponse);
	if (soap_out_PointerTo_ns1__GetSystemMessageResponse(soap, tag?tag:"ns1:GetSystemMessageResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetSystemMessageResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetSystemMessageResponse(struct soap *soap, _ns1__GetSystemMessageResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetSystemMessageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetSystemMessage(struct soap *soap, _ns1__GetSystemMessage *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetSystemMessage))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetSystemMessage(struct soap *soap, const char *tag, int id, _ns1__GetSystemMessage *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetSystemMessage);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetSystemMessage ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetSystemMessage(struct soap *soap, const char *tag, _ns1__GetSystemMessage **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetSystemMessage **)soap_malloc(soap, sizeof(_ns1__GetSystemMessage *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetSystemMessage *)soap_instantiate__ns1__GetSystemMessage(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetSystemMessage ** p = (_ns1__GetSystemMessage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetSystemMessage, sizeof(_ns1__GetSystemMessage), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetSystemMessage(struct soap *soap, _ns1__GetSystemMessage *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetSystemMessage);
	if (soap_out_PointerTo_ns1__GetSystemMessage(soap, tag?tag:"ns1:GetSystemMessage", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetSystemMessage ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetSystemMessage(struct soap *soap, _ns1__GetSystemMessage **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetSystemMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetSystemNotifyResponse(struct soap *soap, _ns1__GetSystemNotifyResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetSystemNotifyResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetSystemNotifyResponse(struct soap *soap, const char *tag, int id, _ns1__GetSystemNotifyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetSystemNotifyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetSystemNotifyResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetSystemNotifyResponse(struct soap *soap, const char *tag, _ns1__GetSystemNotifyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetSystemNotifyResponse **)soap_malloc(soap, sizeof(_ns1__GetSystemNotifyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetSystemNotifyResponse *)soap_instantiate__ns1__GetSystemNotifyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetSystemNotifyResponse ** p = (_ns1__GetSystemNotifyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetSystemNotifyResponse, sizeof(_ns1__GetSystemNotifyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetSystemNotifyResponse(struct soap *soap, _ns1__GetSystemNotifyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetSystemNotifyResponse);
	if (soap_out_PointerTo_ns1__GetSystemNotifyResponse(soap, tag?tag:"ns1:GetSystemNotifyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetSystemNotifyResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetSystemNotifyResponse(struct soap *soap, _ns1__GetSystemNotifyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetSystemNotifyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetSystemNotify(struct soap *soap, _ns1__GetSystemNotify *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetSystemNotify))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetSystemNotify(struct soap *soap, const char *tag, int id, _ns1__GetSystemNotify *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetSystemNotify);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetSystemNotify ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetSystemNotify(struct soap *soap, const char *tag, _ns1__GetSystemNotify **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetSystemNotify **)soap_malloc(soap, sizeof(_ns1__GetSystemNotify *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetSystemNotify *)soap_instantiate__ns1__GetSystemNotify(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetSystemNotify ** p = (_ns1__GetSystemNotify **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetSystemNotify, sizeof(_ns1__GetSystemNotify), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetSystemNotify(struct soap *soap, _ns1__GetSystemNotify *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetSystemNotify);
	if (soap_out_PointerTo_ns1__GetSystemNotify(soap, tag?tag:"ns1:GetSystemNotify", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetSystemNotify ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetSystemNotify(struct soap *soap, _ns1__GetSystemNotify **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetSystemNotify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UserSetting(struct soap *soap, ns1__UserSetting *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UserSetting))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UserSetting(struct soap *soap, const char *tag, int id, ns1__UserSetting *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UserSetting);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__UserSetting ** SOAP_FMAC4 soap_in_PointerTons1__UserSetting(struct soap *soap, const char *tag, ns1__UserSetting **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UserSetting **)soap_malloc(soap, sizeof(ns1__UserSetting *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__UserSetting *)soap_instantiate_ns1__UserSetting(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__UserSetting ** p = (ns1__UserSetting **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UserSetting, sizeof(ns1__UserSetting), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UserSetting(struct soap *soap, ns1__UserSetting *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__UserSetting);
	if (soap_out_PointerTons1__UserSetting(soap, tag?tag:"ns1:UserSetting", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__UserSetting ** SOAP_FMAC4 soap_get_PointerTons1__UserSetting(struct soap *soap, ns1__UserSetting **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UserSetting(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
